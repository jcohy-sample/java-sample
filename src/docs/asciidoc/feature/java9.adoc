[[java-9-feature]]
= Java 9 新特性

[[java-9-feature-overview]]
== Java 9 新特性一览
Java 9 正式发布于 2017 年 9 月 21 日 .作为 Java 8 之后 3 年半才发布的新版本,Java 9 带 来了很多重大的变化.其中最重要的改动是 Java 平台模块系统的引入.除此之外,还有一些新的特性. 本文对 Java 9 中包含的新特性做了概括性的介绍,可以帮助你快速了解 Java 9.
java 9 提供了超过 150 项新功能特性,包括备受期待的模块化系统、可交互的 REPL 工具: jshell,JDK 编译工具,Java 公共 API 和私有代码,以及安全增强、扩展提升、性能管理改善等.可以说 Java 9 是一个庞大的系统工程,完全做了一个整体改变.


此版本为 "功能性" 版本,并非长期支持版本.Oracle 宣布这些版本只有短期支持(六个月).目前最新的 LTC 版本为 Java 17.目前官网已经不提供 java 9 的下载.
详情参考 <<java-17-feature>>

资料来源:  http://openjdk.java.net/projects/jdk9/

[[java-9-feature-tbl]]
.Java 9 新特性一览
|===
| 新特性| 翻译

| 102: http://openjdk.java.net/jeps/102[Process API Updates]        | API 更新过程

| 110: http://openjdk.java.net/jeps/110[HTTP 2 Client]     | HTTP2 客户端

| 143: http://openjdk.java.net/jeps/143[Improve Contended Locking] | 改善竞争锁

| 158: http://openjdk.java.net/jeps/158[Unified JVM Logging] | 统一 JVM 日志记录

| 165: http://openjdk.java.net/jeps/165[Compiler Control]    | 编译器控制

| 193: http://openjdk.java.net/jeps/193[Variable Handles]    | 变量处理

| 197: http://openjdk.java.net/jeps/197[Segmented Code Cache] | 分段代码缓存

| 199: http://openjdk.java.net/jeps/199[Smart Java Compilation, Phase Two] | 聪明的 Java 编译,第二阶段

| 200: http://openjdk.java.net/jeps/200[The Modular JDK]     | 模块化 JDK

| 201: http://openjdk.java.net/jeps/201[Modular Source Code] | 模块化的源代码

| 211: http://openjdk.java.net/jeps/211[Elide Deprecation Warnings on Import Statements] | 导入语句时省略警告信息

| 212: http://openjdk.java.net/jeps/212[Resolve Lint and Doclint Warnings] | 解决 Lint 和 Doclint 警告

| 213: http://openjdk.java.net/jeps/213[Milling Project Coin] | 研磨项目 Coin

| 214: http://openjdk.java.net/jeps/214[Remove GC Combinations Deprecated in JDK 8] | 移除 JDK 8 过时的 GC 组合

| 215: http://openjdk.java.net/jeps/215[Tiered Attribution for javac] | javac 分层归因

| 216: http://openjdk.java.net/jeps/216[Process Import Statements Correctly] | 正确处理导入语句

| 217: http://openjdk.java.net/jeps/217[Annotations Pipeline 2.0] | 注解管道

| 219: http://openjdk.java.net/jeps/219[Datagram Transport Layer Security (DTLS)] | 数据报传输层安全性(DTLS)

| 220: http://openjdk.java.net/jeps/220[Modular Run-Time Images] | 模块化运行时图像

| 221: http://openjdk.java.net/jeps/221[Simplified Doclet API] | 简化 Doclet API

| 222: http://openjdk.java.net/jeps/222[jshell: The Java Shell (Read-Eval-Print Loop)] | jshell:Java Shell(Read-Eval-Print-Loop)

| 223: http://openjdk.java.net/jeps/223[New Version-String Scheme] | 字符串新版本方案

| 224: http://openjdk.java.net/jeps/224[HTML5 Javadoc]     | Javadoc 支持 HTML5

| 225: http://openjdk.java.net/jeps/225[Javadoc Search]      | Javadoc 搜索

| 226: http://openjdk.java.net/jeps/226[UTF-8 Property Files] | utf-8 属性文件

| 227: http://openjdk.java.net/jeps/227[Unicode 7.0]    | Unicode 7.0

| 228: http://openjdk.java.net/jeps/228[Add More Diagnostic Commands] | 添加更多的诊断命令

| 229: http://openjdk.java.net/jeps/229[Create PKCS12 Keystores by Default] | 创建 PKCS12 默认密钥存储库

| 231: http://openjdk.java.net/jeps/231[Remove Launch-Time JRE Version Selection] | 删除启动 JRE 版本选择

| 232: http://openjdk.java.net/jeps/232[Improve Secure Application Performance] | 提高安全应用程序性能

| 233: http://openjdk.java.net/jeps/233[Generate Run-Time Compiler Tests Automatically] | 自动生成运行时编译器测试

| 235: http://openjdk.java.net/jeps/235[Test Class-File Attributes Generated by javac] | 测试 javac 生成的类文件属性

| 236: http://openjdk.java.net/jeps/236[Parser API for Nashorn] | Nashorn 解析器 API

| 237: http://openjdk.java.net/jeps/237[Linux/AArch64 Port]  | Linux/AArch64 端口

| 238: http://openjdk.java.net/jeps/238[Multi-Release JAR Files] | Multi-Release JAR文件

| 240: http://openjdk.java.net/jeps/240[Remove the JVM TI hprof Agent] | 删除 JVM TI hprof 代理

| 241: http://openjdk.java.net/jeps/241[Remove the jhat Tool] | 删除 jhat 工具

| 243: http://openjdk.java.net/jeps/243[Java-Level JVM Compiler Interface] | java 级别 JVM 编译器接口

| 244: http://openjdk.java.net/jeps/244[TLS Application-Layer Protocol Negotiation Extension] | TLS 应用层协议谈判扩展

| 245: http://openjdk.java.net/jeps/245[Validate JVM Command-Line Flag Arguments] | JVM 命令行标记参数进行验证

| 246: http://openjdk.java.net/jeps/246[Leverage CPU Instructions for GHASH and RSA] | 利用 CPU 指令 GHASH 和 RSA

| 247: http://openjdk.java.net/jeps/247[Compile for Older Platform Versions] | 老平台版本编译

| 248: http://openjdk.java.net/jeps/248[Make G1 the Default Garbage Collector] | 设置 G1 为默认的垃圾收集器

| 249: http://openjdk.java.net/jeps/249[OCSP Stapling for TLS] | OCSP 装订 TLS

| 250: http://openjdk.java.net/jeps/250[Store Interned Strings in CDS Archives] | CDS 档案中存储实际字符串

| 251: http://openjdk.java.net/jeps/251[Multi-Resolution Images] | 多分辨率图像

| 252: http://openjdk.java.net/jeps/252[Use CLDR Locale Data by Default] | 使用系统默认语言环境数据

| 253: http://openjdk.java.net/jeps/253[Prepare JavaFX UI Controls & CSS APIs for Modularization] | 准备 JavaFX UI 控件和 CSS api 用于模块化

| 254: http://openjdk.java.net/jeps/254[Compact Strings]     | 紧凑的字符串

| 255: http://openjdk.java.net/jeps/255[Merge Selected Xerces 2.11.0 Updates into JAXP] | 合并选定的 Xerces 2.11.0 更新到 JAXP

| 256: http://openjdk.java.net/jeps/256[BeanInfo Annotations] | BeanInfo 注解

| 257: http://openjdk.java.net/jeps/257[Update JavaFX/Media to Newer Version of GStreamer] | 更新 JavaFX/Media 到 GStreamer 的新版本

| 258: http://openjdk.java.net/jeps/258[HarfBuzz Font-Layout Engine] | HarfBuzz 文字编排引擎

| 259: http://openjdk.java.net/jeps/259[Stack-Walking API]   | 提供 Stack – Walking API

| 260: http://openjdk.java.net/jeps/260[Encapsulate Most Internal APIs] | 封装内部 api

| 261: http://openjdk.java.net/jeps/261[Module System]       | 模块系统

| 262: http://openjdk.java.net/jeps/262[TIFF Image I/O]      | TIFF 图像 I/O

| 263: [HiDPI Graphics on Windows and Linux](http://openjdk.java.net/jeps/263) | Windows 和 Linux 上的 HiDPI 图形

| 264: http://openjdk.java.net/jeps/264[Platform Logging API and Service] | 日志 API 和服务平台

| 265: http://openjdk.java.net/jeps/265[Marlin Graphics Renderer] | Marlin 图形渲染器

| 266: http://openjdk.java.net/jeps/266[More Concurrency Updates] | 更多的并发更新

| 267: http://openjdk.java.net/jeps/267[Unicode 8.0]         | Unicode 8.0

| 268: http://openjdk.java.net/jeps/268[XML Catalogs]       | XML 目录

| 269: http://openjdk.java.net/jeps/269[Convenience Factory Methods for Collections] | 方便的集合工厂方法

| 270: http://openjdk.java.net/jeps/270[Reserved Stack Areas for Critical Sections] | 保留堆栈领域至关重要的部分

| 271: http://openjdk.java.net/jeps/271[Unified GC Logging]  | 统一的 GC 日志记录

| 272: http://openjdk.java.net/jeps/272[Platform-Specific Desktop Features] | 特定于平台的桌面功能

| 273: http://openjdk.java.net/jeps/273[DRBG-Based SecureRandom Implementations] | 基于 DRBG 的 SecureRandom 实现

| 274: http://openjdk.java.net/jeps/274[Enhanced Method Handles] | 增强的方法处理

| 275: http://openjdk.java.net/jeps/275[Modular Java Application Packaging] | 模块化 Java 应用程序包装

| 276: http://openjdk.java.net/jeps/276[Dynamic Linking of Language-Defined Object Models] | 语言定义对象模型的动态链接

| 277: http://openjdk.java.net/jeps/277[Enhanced Deprecation] | 增强的弃用

| 278: http://openjdk.java.net/jeps/278[Additional Tests for Humongous Objects in G1] | 为 G1 的极大对象提供额外的测试

| 279: http://openjdk.java.net/jeps/279[Improve Test-Failure Troubleshooting] | 改善测试失败的故障排除

| 280: http://openjdk.java.net/jeps/280[Indify String Concatenation] | Indify 字符串连接

| 281: http://openjdk.java.net/jeps/281[HotSpot C++ Unit-Test Framework] | 热点c++的单元测试框架

| 282: http://openjdk.java.net/jeps/282[jlink: The Java Linker] | jlink:Java 连接器

| 283: http://openjdk.java.net/jeps/283[Enable GTK 3 on Linux] | 在 Linux 上启用GTK 3

| 284: http://openjdk.java.net/jeps/284[New HotSpot Build System] | 新热点的构建系统

| 285: http://openjdk.java.net/jeps/285[Spin-Wait Hints]     | 循环等待提示

| 287: http://openjdk.java.net/jeps/287[SHA-3 Hash Algorithms] | SHA-3 散列算法

| 288: http://openjdk.java.net/jeps/288[Disable SHA-1 Certificates] | 禁用 sha - 1证书

| 289: http://openjdk.java.net/jeps/289[Deprecate the Applet API] | 标记过时的 Applet API

| 290: http://openjdk.java.net/jeps/290[Filter Incoming Serialization Data] | 过滤传入的序列化数据

| 291: http://openjdk.java.net/jeps/291[Deprecate the Concurrent Mark Sweep (CMS) Garbage Collector] | 反对并发标记清理垃圾收集器(CMS)

| 292: http://openjdk.java.net/jeps/292[Implement Selected ECMAScript 6 Features in Nashorn] | 实现选定的 ECMAScript Nashorn 6 特性

| 294: http://openjdk.java.net/jeps/294[Linux/s390x Port]  | Linux/s390x 端口

| 295: http://openjdk.java.net/jeps/295[Ahead-of-Time Compilation] | 提前编译

| 297: http://openjdk.java.net/jeps/297[Unified arm32/arm64 Port] | 统一的 arm32/arm64端口

| 298: http://openjdk.java.net/jeps/298[Remove Demos and Samples] | 删除演示和样本

| 299: http://openjdk.java.net/jeps/299[Reorganize Documentation] | 整理文档
|===

[NOTE]
====
由于 Java 9 特性众多，这里不做一一介绍，只介绍比较重要有意义的特性
====

[[java-9-feature-jigsaw]]
== 模块化系统 Jigsaw > Modularity

[[java-9-feature-jigsaw-Feature]]
=== 官方 Feature

- 200: The Modular JDK 201: Modular Source Code

- 220: Modular Run-Time Images

- 260: Encapsulate Most Internal APIs

- 261: Module System

- 282: jlink: The Java Linker

[[java-9-feature-jigsaw-overview]]
=== 概述

Java 平台模块系统,也就是 Project Jigsaw,把模块化开发实践引入到了 Java 平台中.在引入了模块系统之后,JDK 被重新组织成 94 个模块.Java 应用可以通过新增的 jlink 工具,创建出只包含所依赖的 JDK 模块的自定义运行时镜像.这样可以极大的减少 Java 运行时环境的大小.这对于目前流行的不可变基础设施的实践来说,镜像的大小的减少可以节省很多存储空间和带宽资源 .

模块化开发的实践在软件开发领域并不是一个新的概念.Java 开发社区已经使用这样的模块化实践有相当长的一段时间.主流的构建工具,包括 `Apache Maven` 和 `Gradle` 都支持把一个大的项目划分成若干个子项目.子项目之间通过不同的依赖关系组织在一起.每个子项目在构建之后都会产生对应的 JAR 文件. 在 Java 9 中 ,已有的这些项目可以很容易的升级转换为 Java 9 模块 ,并保持原有的组织结构不变.

Java 9 模块的重要特征是在其工件(artifact)的根目录中包含了一个描述模块的 module-info.class 文 件. 工件的格式可以是传统的 JAR 文件或是 Java 9 新增的 JMOD 文件.这个文件由根目录中的源代码文件 module-info.java 编译而来.该模块声明文件可以描述模块的不同特征.模块声明文件中可以包含的内容如下:

- 模块导出的包: 使用 `exports` 可以声明模块对其他模块所导出的包.包中的 `public` 和 `protected` 类型,以及这些类型的 `public` 和 `protected` 成员可以被其他模块所访问.没有声明为导出的包相当于模块中的私有成员,不能被其他模块使用.

- 模块的依赖关系: 使用 `requires` 可以声明模块对其他模块的依赖关系.使用 `requires transitive` 可以把一个模块依赖声明为传递的.传递的模块依赖可以被依赖当前模块的其他模块所读取. 如果一个模块所导出的类型的型构中包含了来自它所依赖的模块的类型,那么对该模块的依赖应该声明为传递的.

- 服务的提供和使用: 如果一个模块中包含了可以被 `ServiceLocator` 发现的服务接口的实现 ,需要使用 `provides with` 语句来声明具体的实现类;如果一个模块需要使用服务接口,可以使用 `uses` 语句来声明.

[[java-9-feature-jigsaw-use]]
=== 使用

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
module helloworld {
    exports com.jcohy.demo;
}

module test {
    requires helloworld;
    provides com.jcohy.common.DemoService with
        com.mycompany.sample.DemoServiceImpl;
}
----


模块系统中增加了模块路径的概念.模块系统在解析模块时,会从模块路径中进行查找.为了保持与之前 Java 版本的兼容性,`CLASSPATH` 依然被保留.所有的类型在运行时都属于某个特定的模块.对于从 `CLASSPATH` 中加载的类型,它们属于加载它们的类加载器对应的未命名模块.可以通过 `Class` 的 `getModule()` 方法来获取到表示其所在模块的 `Module` 对象.

在 JVM 启动时,会从应用的根模块开始,根据依赖关系递归的进行解析,直到得到一个表示依赖关系的图.如果解析过程中出现找不到模块的情况,或是在模块路径的同一个地方找到了名称相同的模块,模块解析过程会终止,JVM 也会退出.Java 也提供了相应的 API 与模块系统进行交互.

[[java-9-feature-jshell]]
== Jshell

[[java-9-feature-feature]]
=== 官方 Feature

* 222: jshell: The Java Shell (Read-Eval-Print Loop)

`jshell` 是 Java 9 新增的一个实用工具.`jshell` 为 Java 增加了类似 NodeJS 和 Python 中的读取-求值-打印循环( Read-Evaluation-Print Loop ) . 在 `jshell` 中 可以直接 输入表达式并查看其执行结果.当需要测试一个方法的运行效果,或是快速的对表达式进行求值时,`jshell` 都非常实用.
只需要通过 `jshell` 命令启动 `jshell`,然后直接输入表达式即可.每个表达式的结果会被自动保存下来 ,以数字编号作为引用,类似 `$1` 和 `$2` 这样的名称 .可以在后续的表达式中引用之前语句的运行结果. 在 `jshell` 中 ,除了表达式之外,还可以创建 Java 类和方法.`jshell` 也有基本的代码完成功能.


[[java-9-feature-use]]
=== 使用举例


1、调出 jshell

[source,shell]
----
jshell
----

2、获取帮助

[source,shell]
----
jshell> /help intro
----

3、基本使用

[source,shell]
----
jshell> int add(int x, int y) {
    ...> return x + y;
    ...> }
 | 已创建 方法 add(int,int)
----

接着就可以在 jshell 中直接使用这个方法

[source,shell]
----
jshell> add(1, 2)
$19 ==> 3
----

4、导入包

[source,shell]
----
jshell> import java.util.*
----

5、查看默认导入的包

[source,shell]
----
jshell> /imports
----

6、代码补全
TAB 键

7、列出当前 session 里所有有效的代码片段

[source,shell]
----
jshell> /list
----
8、查看当前 session 下所有创建过的变量

[source,shell]
----
jshell> /var
----

9、查看当前 session 下所有创建过的方法

[source,shell]
----
jshell> /methods
----

10、从外部文件加载源代码

[source,shell]
----
jshell> /open E:\hello.java
----

11、没有受检异常(编译时异常)

[source,shell]
----
jshell> URL url = new URL("http://www.baidu.com");
url ==> http://www.baidu.com
----

说明: 本来应该强迫我们捕获一个 `IOException`,但却没有出现.因为 `jShell` 在后台为我们隐藏了.

12、打开 Jshell 编辑器

[source,shell]
----
jshell> /edit
----

13、打开 Jshell 编辑器(使用其他编辑器)

[source,shell]
----
jshell> /set editor "C:\\Program Files\\Sublime Text 3\\sublime_text.exe"
----

13、退出 Jshell

[source,shell]
----
jshell> /exit
 | 再见
----

[[java-9-feature-jar]]
== 多版本兼容 jar 包

[[java-9-feature-jar-feature]]
=== 官方 Feature

* 238: Multi-Release JAR Files

当一个新版本的 Java 出现的时候,你的库用户要花费数年时间才会切换到这个新的版本.这就意味着库得去向后兼容你想要支持的最老的 Java 版本(许多情况下就是 Java 6 或者 Java 7).这实际上意味着未来的很长一段时间,你都不能在库中运用Java 9 所提供的新特性.幸运的是,多版本兼容 jar 功能能让你创建仅在特定版本的 Java 环境中运行库程序选择使用的 class 版本.

[[java-9-feature-jar-overview]]
=== 概述

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
jar root
  - A.class
  - B.class
  - C.class
  - D.class
  - META-INF
     - versions
        - 9
           - A.class
           - B.class
        - 10
           - A.class
----

说明:
在上述场景中, `root.jar` 可以在 Java 9 中使用, 不过 A或B 类使用的不是顶层的 `root.A` 或 `root.B` 这两个 class, 而是处在 `META-INF/versions/9` 下面的这两个.这是特别为 Java 9 准备的 class 版本,可以运用 Java 9 所提供的特性和库.在将来的支持 Java 10 JDK 上,它将看到 A 的 Jdk 10 特定版本和 B 的 Jdk 9 特定版本;同时,在早期的 Java 诸版本中使用这个 JAR 也是能运行的,因为较老版本的 Java 只会看到顶层的A类或 B 类.

[[java-9-feature-jar-use]]
=== 使用

1、创建一个类,使用 Java 9 版本语法

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
import java.util.Set;
/**
 * Created by jcohy on 2017/12/28 0028.
 */
public class Generator {

    public Set<String> createStrings() {
        return Set.of("Java", "9");
    }

}
----

2、创建一个同名类,使用 Java 8 版本语法

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 8
----
import java.util.Set;
import java.util.HashSet;

public class Generator {
    public Set<String> createStrings() {
        Set<String> strings = new HashSet<String>();
        strings.add("Java");
        strings.add("8");
        return strings;
    }
}
----

3、创建测试类

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
public class Application {
   public static void testMultiJar(){
      Generator gen = new Generator();
      System.out.println("Generated strings: " + gen.createStrings());
   }
}
----

4、打包

[source,shell,indent=0,subs="verbatim,quotes",role="primary"]
.Shell
----
javac -d build --release 8 src/main/java/com/jcohy/study/*.java
javac -d build9 --release 9 src/main/java9/com/jcohy/study/*.java
jar --create --main-class=Application --file multijar.jar -C build . --release 9 -C build9 .
----

[[java-9-feature-grammar]]
== 语法改进

[[java-9-feature-grammar-interface]]
=== 接口的私有方法

[[java-9-feature-grammar-interface-feature]]
==== 官方 Feature

213: Milling Project Coin

Java 8 中规定接口中的方法除了抽象方法之外,还可以定义静态方法和默认的方法.一定程度上,扩展了接口的功能,此时的接口更像是一个抽象类.
在 Java 9 中,接口更加的灵活和强大,连方法的访问权限修饰符都可以声明为 `private` 的了,这些私有方法将提高接口内代码的可重用性。例如，如果两个默认方法需要共享代码，私有方法将允许它们这样做，但不会将该私有方法暴露给它的实现类。

在接口中使用私有方法有四个规则：

* 接口私有方法不能是抽象的。
* 私有方法只能在接口内部使用。
* 私有静态方法可以在其他静态和非静态接口方法中使用。
* 私有非静态方法不能在私有静态方法中使用。

在接口中使用私有方法的一个例子:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
include::{java-code}/java9/PrivateInterface.java[]
----

让我们再看一个例子来了解接口私有方法的用法。我们创建了一个 `CustomCalculator`  类，里面包含两个方法，第一个方法接收整数并添加所有偶数，第二个方法接收整数并添加所有奇数。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
include::{java-code}/java9/CustomCalculator.java[]
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
include::{java-code}/java9/Main.java[]
----

==== 总结


|===
|方法类型 | JDK

| public abstract
| Java 7

| public default
| Java 8

| public static
| Java 8

| private
| Java 9

| private static
| Java 9
|===

[[java-9-feature-grammar-diamond]]
=== 钻石操作符

我们将能够与匿名实现类共同使用钻石操作符(diamond operator),在 Java 8 中如下的操作是会报错的:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 8
----
include::{java-code}/java9/Tests.java[tag=interface1]
----

编译报错信息: `'<>'` cannot be used with anonymous classes

[[java-9-feature-grammar-try]]
=== try 语句

在 Java 8 之前,我们习惯于这样处理资源的关闭:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 8
----
include::{java-code}/java9/Tests.java[tag=resource1]
----

java 8 中,可以实现资源的自动关闭,但是要求执行后必须关闭的所有资源必须在 try 子句中初始化,否则编译不通过.如下例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 8
----
include::{java-code}/java9/Tests.java[tag=resource2]
----

java 9 中,用资源语句编写 `try` 将更容易,我们可以在 `try` 子句中使用已经初始化过的资源,此时的资源是 `final` 的:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
include::{java-code}/java9/Tests.java[tag=resource3]
----

[[java-9-feature-grammar-underscope]]
=== UnderScope(下划线使用的限制)

在 java 8 中,标识符可以独立使用 `_` 来命名:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 8
----
String _ = "hello";
System.out.println(_);
----

但是,在 java 9 中规定 `_` 不再可以单独命名标识符了,如果使用,会报错

[[java-9-feature-grammar-collection]]
=== 集合工厂方法

Java 9 中的新增了工厂方法创建不可变的集合，如不可变 list、不可变 set 和不可变 map。

==== 创建不可变 List

使用 `List.of()` 静态工厂方法创建不可变的 list，他包含以下重载方法

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
static <E> List<E>  of()
static <E> List<E>  of(E e1)
static <E> List<E>  of(E e1, E e2)
static <E> List<E>  of(E e1, E e2, E e3)
static <E> List<E>  of(E e1, E e2, E e3, E e4)
static <E> List<E>  of(E e1, E e2, E e3, E e4, E e5)
static <E> List<E>  of(E e1, E e2, E e3, E e4, E e5, E e6)
static <E> List<E>  of(E e1, E e2, E e3, E e4, E e5, E e6, E e7)
static <E> List<E>  of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)
static <E> List<E>  of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)
static <E> List<E>  of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)
//varargs
static <E> List<E>  of(E... elements)
----

这些方法具有以下特点：

* 这些列表是不可变的。 不能在这些列表中添加、删除或替换元素。 调用任何 mutator 方法（即 `add`、`addAll`、`clear`、`remove`、`removeAll`、`replaceAll`）总是会导致抛出 `UnsupportedOperationException`。
* 不允许 `null` 元素。 尝试添加 `null` 元素会导致 `NullPointerException`。
* 如果所有元素都是可序列化的，则它们是可序列化的。
* 列表中元素的顺序与提供的参数或提供的数组中元素的顺序相同。

查看下面的例子：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
include::{java-code}/java9/ImmutableCollections.java[tag=list]
----

==== 不可变 Set

`Set` 的行为与 `List` 非常相似，只有很少的差异。例如

* `Set` 不允许重复元素。 任何重复元素都将导致 `IllegalArgumentException`。
* 集合元素的迭代顺序未指定，可能会发生变化。

所有 `Set` 工厂方法都具有与 `List` 相同的签名。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
static <E> Set<E> of()
static <E> Set<E> of(E e1)
static <E> Set<E> of(E e1, E e2)
static <E> Set<E> of(E e1, E e2, E e3)
static <E> Set<E> of(E e1, E e2, E e3, E e4)
static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5)
static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6)
static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7)
static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)
static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)
static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)
//varargs
static <E> Set<E> of(E... elements)
----

查看下面的例子：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
include::{java-code}/java9/ImmutableCollections.java[tag=list]
----

==== 创建不可变 Map

`Map` 工厂方法与 `List` 或 `Set` 重载工厂方法相同。 唯一的区别是 `of` 方法的签名采用交替的键和值作为参数。 例如

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
static <K,V> Map<K,V> of()
static <K,V> Map<K,V> of(K k1, V v1)
static <K,V> Map<K,V> of(K k1, V v1, K k2, V v2)
...
...
static <K,V> Map<K,V> ofEntries(Map.Entry<? extends K,? extends V>... entries)
----

Java 9 还提供了一种创建 Map entry 实例的特殊方法。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
static <K,V> Map.Entry<K,V> entry(K k, V v)
----

查看下面的例子：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
include::{java-code}/java9/ImmutableCollections.java[tag=list]
----

[[java-9-feature-grammar-stream]]
=== 增强的 Stream API

Stream 中增加了新的方法 `ofNullable`、`dropWhile`、`takeWhile` 和 `iterate` 重载方法.

`takeWhile` 和 `dropWhile` 允许您基于谓词获取流的一部分。`takeWhile` 方法接受所有值，直到谓词返回 `false` 为止, `dropWhile` 方法丢弃所有值，直到它与谓词匹配为止 这里的流可以是有序的或无序的，所以：

* 在有序流中，`takeWhile` 从头开始保留满足条件的元素，一旦遇到不满足的元素就结束
* 在无序流中，`takeWhile` 返回由从与给定谓词匹配的流中提取的元素子集组成的流

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
include::{java-code}/java9/Tests.java[tag=takeWhile]
----

`dropWhile` 方法与 `takeWhile` 方法相反。

* 在有序流中，`dropWhile` 从头开始去掉满足条件的元素，一旦遇到不满足元素的就结束
* 在无序流中，`dropWhile` 从头开始去掉满足条件的元素子集，后剩余的元素。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
include::{java-code}/java9/Tests.java[tag=dropWhile]
----

在 如下代码中,流中包含了从 1 到 5 的 元素.断言检查元素是否为奇数.第一个元素 1 被删除,结果流中包含 4 个元素.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
include::{java-code}/java9/Tests.java[tag=testDropWhile]
----

`iterate()` 方法用于创建以某个元素（种子）开头的流，随后该元素通过连续应用 UnaryOperator 运算生成。 其结果是无限流。如果要终止流，需要使用 `limit` 或其他一些短路函数，如 `findFirst` 或 `findAny`。

Java 8 中 `iterate` 方法签名:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 8
----
static Stream iterate(final T seed, final UnaryOperator f)
----

在 Java 9 中，新的重载版本的 `iterate` 将 `Predicate` 作为第二个参数：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
static Stream iterate(T seed, Predicate hasNext, UnaryOperator next)
----

让我们看一个例子来了解一下在 Java 8 和 Java 9 中的区别

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
include::{java-code}/java9/IterateTest.java[tag=java8]
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
include::{java-code}/java9/IterateTest.java[tag=java9]
----

在 Java 8 之前，流中不能有 `null` 值。 它会导致 `NullPointerException`。

在 Java 9 中，`ofNullable` 方法允许您创建一个单元素流，如果不为空则包装一个值，否则为 empty 流。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
include::{java-code}/java9/Tests.java[tag=ofNullable]
----

[[java-9-feature-grammar-stream-collectors]]
==== Collectors

`Collectors` 中增加了新的方法 `filtering` 和 `flatMapping`.在 如下代码中,对于输入的 `String` 流 ,先通过 `flatMapping` 把 `String` 映射成 `Integer` 流 ,再把所有的 `Integer` 收集到一个集合中.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
include::{java-code}/java9/Tests.java[tag=testFlatMapping]
----

[[java-9-feature-grammar-stream-optional]]
==== Optional

`Optional` 类中新增了 `ifPresentOrElse`、`or` 和 `stream` 等方法.在 如下代码中,Optional 流中包含 3 个 元素,其中只有 2 个有值.在使用 `flatMap` 之后,结果流中包含了 2 个值.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
include::{java-code}/java9/Tests.java[tag=testStream]
----

[[java-9-feature-grammar-deprecated]]
=== @Deprecated 注解变化

从 Java 9 开始，`@Deprecated` 注解将具有两个属性，即 `forRemoval` 和 `since`。

* forRemoval – 指示带注解的元素是否会在未来版本中被删除。
* since - 它返回注解元素被弃用的版本。
强烈建议使用 `@deprecated` javadoc 标签在文档中解释弃用程序元素的原因。 如果可以，文档还应建议并链接到推荐的替代 API。 替换 API 通常具有微妙的不同语义，因此也应讨论此类问题。

[[java-9-feature-string]]
== String 存储结构变更

[[java-9-feature-string-feature]]
=== 官方 Feature

* JEP 254: Compact Strings

[[java-9-feature-string-motivation]]
=== 动机

String 类的在 jdk8 之前的实现是采用的 char 数组来存储的,每个字符使用两个字节(十六位).然而, 从许多不同的应用程序收集到的数据表明,字符串是堆使用的主要组成部分,而且,大多数 String 对象仅包含 Latin-1 这样的拉丁字符. 这样的字符仅需要一个字节的存储空间,因此此类 String 对象的内部 char 数组中的一半空间都没有使用.

[[java-9-feature-string-impl]]
=== 实现

我们建议将 String 类的内部表示形式从 UTF-16 字符数组更改为字节数组,再加上一个 `encoding-flag` 字段.新的 String 类将存储基于字符串内容编码为 `ISO-8859-1/Latin-1`(每个字符一个字节)或 UTF-16(每个字符两个字节)的字符.`encoding-flag` 字段将指示使用哪种编码.
与字符串相关的类(例如 `AbstractStringBuilder`,`StringBuilder` 和 `StringBuffer`)将更新为使用相同的表示形式,HotSpot VM的固有字符串操作也将使用相同的表示形式.
这纯粹是实现更改,不更改现有的公共接口.没有计划添加任何新的公共 API 或其他接口.

[[java-9-feature-multi-images]]
== 多分辨率图像 API

[[java-9-feature-multi-images-feature]]
=== 官方 Feature

* 251: Multi-Resolution Images
* 263: HiDPI Graphics on Windows and Linux

在 `Mac` 上,JDK 已经支持视网膜显示,但在 `Linux` 和 `Windows` 上,它并没有.在那里,Java 程序在当前的高分辨率屏幕上可能看起来很小,不能使用它们.这是因为像素用于这些系统的大小计算(无论像素实际有多大).毕竟,高分辨率显示器的有效部分是像素非常小.

JEP 263 以这样的方式扩展了JDK,即 `Windows` 和 `Linux` 也考虑到像素的大小.为此,使用比现在更多的现代 API: Direct2D for Windows和GTK +,而不是 Xlib for Linux.图形,窗口和文本由此自动缩放.

JEP 251 还提供处理多分辨率图像的能力,即包含不同分辨率的相同图像的文件.根据相应屏幕的DPI度量,然后以适当的分辨率使用图像.

[[java-9-feature-multi-images-use]]
=== 使用

* 新的API定义在 `java.awt.image` 包下
* 将不同分辨率的图像封装到一张(多分辨率的)图像中,作为它的变体
* 获取这个图像的所有变体
* 获取特定分辨率的图像变体-表示一张已知分辨率单位为 DPI 的特定尺寸大小的逻辑图像,并且这张图像是最佳的变体.
* 基于当前屏幕分辨率大小和运用的图像转换算法,`java.awt.Graphics` 类可以从接口 `MultiResolutionImage` 获取所需的变体.
* `MultiResolutionImage` 的基础实现是 `java.awt.image.BaseMultiResolutionImage`

[[java-9-feature-http]]
== 全新的 HTTP 客户端 API

[[java-9-feature-http-feature]]
=== 官方 Feature

* 110: HTTP 2 Client

HTTP/1.1 和 HTTP/2 的主要区别是如何在客户端和服务器之间构建和传输数据.HTTP/1.1 依赖于请求/响应周期. HTTP/2 允许服务器 "push" 数据: 它可以发送比客户端请求更多的数据. 这使得它可以优先处理并发送对于首先加载网页至关重要的数据.

Java 9 中有新的方式来处理 HTTP 调用.它提供了一个新的 HTTP 客户端( `HttpClient` ),它将替代仅适用于 blocking 模式的 `HttpURLConnection` (`HttpURLConnection` 是在 HTTP 1.0 的时代创建的,并使用了协议无关的方法),并提供对 WebSocket 和 HTTP/2 的支持.

此外,HTTP 客户端还提供 API 来处理 HTTP/2 的特性,比如流和服务器推送等功能.

全新的 HTTP 客户端 API 可以从 `jdk.incubator.httpclient` 模块中获取.因为在默认情况下,这个模块是不能根据 `classpath` 获取的,需要使用 `add modules` 命令选项配置这个模块,将这个模块添加到 `classpath` 中.

[[java-9-feature-http-use]]
=== 使用

<<java-11-feature-httpclient>>

[[java-9-feature-StackWalking]]
== 提供 Stack – Walking API

[[java-9-feature-StackWalking-feature]]
=== 官方 Feature

* 259: Stack-Walking API

栈是一种后进先出 (LIFO) 数据结构。在 JVM 级别，用栈存储帧（简称栈帧）。每次调用方法时都会创建一个新栈帧并将其放置在栈顶。当方法调用完成时，一个栈帧被销毁（从栈中弹出）。每一个栈帧都包含自己的局部变量数组，以及自己的操作数栈、返回值和对当前方法类的运行时常量池的引用。

在给定线程中，任何时候只有一个栈帧处于活动状态。活动帧称为当前帧，其方法称为当前方法。

在 Java 8 之前，`StackTraceElement` 表示栈帧元素。要获得完整的堆栈，您必须使用 `Thread.getStackTrace()` 和 `Throwable.getStackTrace()`。它返回了一个 `StackTraceElement` 数组，您可以对其进行迭代以获取所需的信息。

在 Java 9 中，引入了一个新类 `StackWalker`。该类使用当前线程的堆栈帧的顺序流提供简单有效的堆栈遍历。 `StackWalker` 类非常高效，因为它惰性地对栈帧进行评估。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
// Prints the details of all stack frames of the current thread

StackWalker.getInstance().forEach(System.out::println);
----

[[java-9-feature-compilation]]
== 智能 Java 编译工具

[[java-9-feature-compilation-feature]]
=== 官方 Feature

* 139: Enhance javac to Improve Build Speed.
* 199: Smart Java Compilation, Phase Two

智能 java 编译工具( sjavac )的第一个阶段始于 JEP139 这个项目,用于在多核处理器情况下提升 JDK 的编译速度.如今,这个项目已经进入第二阶段,即 JEP199,其目的是改进 Java 编译工具,并取代目前 JDK 编译工具 javac,继而成为 Java 环境默认的通用的智能编译工具.
JDK 9 还更新了 javac 编译器以便能够将 java 9 代码编译运行在低版本 Java 中.

[[java-9-feature-logging]]
== 统一的 JVM 日志系统

[[java-9-feature-logging-feature]]
=== 官方 Feature

* 158: Unified JVM Logging
* 271: Unified GC Logging

日志是解决问题的唯一有效途径: 曾经很难知道导致 JVM 性能问题和导致 JVM 崩溃的根本原因.不同的 JVM 日志的碎片化和日志选项(例如: JVM 组件对于日志使用的是不同的机制和规则),这使得 JVM 难以进行调试.

解决该问题最佳方法: 对所有的 JVM 组件引入一个单一的系统,这些 JVM 组件支持细粒度的和易配置的 JVM 日志.

Java 9 中 ,JVM 有了统一的日志记录系统,可以使用新的命令行选项 `-Xlog` 来控制 JVM 上 所有组件的日志记录.该日志记录系统可以设置输出的日志消息的标签、级别、修饰符和输出目标等.Java 9 移除了在 Java 8 中 被废弃的垃圾回收器配置组合,
同时 把 G1 设为默认的垃圾回收器实现.另外,CMS 垃圾回收器已经被声明为废弃.Java 9 也增加了很多可以通过 `jcmd` 调用的诊断命令.

[[java-9-feature-html5]]
== javadoc 的 HTML5 支持

[[java-9-feature-html5-feature]]
=== 官方 Feature

* 224: HTML5 Javadoc
* 225: Javadoc Search

jdk 8 : 生成的 java 帮助文档是在 HTML 4 中,而 HTML 4 已经是很久的标准了.

jdk 9 : javadoc 的输出,现在符合兼容 HTML 5 标准.

[[java-9-feature-nashorn]]
== Javascript 引擎升级: Nashorn

[[java-9-feature-nashorn-feature]]
=== 官方 Feature

* 236: Parser API for Nashorn
* 292: Implement Selected ECMAScript 6 Features in Nashorn

Nashorn 项目在 JDK 9 中得到改进,它为 Java 提供轻量级的 Javascript 运行时.Nashorn 项目跟随 Netscape 的 Rhino 项目,目的是为了在 Java 中实现一个高性能但轻量级的 Javascript 运行时.Nashorn 项目使得 Java 应用能够嵌入 Javascript.它在 JDK 8 中为 Java 提供一个 Javascript 引擎.
JDK 9 包含一个用来解析 Nashorn 的 `ECMAScript` 语法树的 API.这个 API 使得 IDE 和服务端框架不需要依赖 Nashorn 项目的内部实现类,就能够分析 ECMAScript 代码.

[[java-9-feature-dynamic-compilation]]
== javadoc 的 HTML5 支持

[[java-9-feature-dynamic-compilation-feature]]
=== 官方 Feature

* 243: Java-Level JVM Compiler Interface

* 295: Ahead-of-Time Compilation

Oracle 一直在努力提高 Java 启动和运行时性能,希望其能够在更广泛的场景达到或接近本地语言的性能.但是,直到今天,谈到 Java,很多 C/C++ 开发者还是会不屑地评价为启动慢,吃内存.

简单说,这主要是因为 Java 编译产生的类文件是 Java 虚拟机可以理解的二进制代码,而不是真正的可执行的本地代码,需要 Java 虚拟机进行解释和编译,这带来了额外的开销.

JIT(Just-in-time)编译器可以在运行时将热点编译成本地代码,速度很快.但是 Java 项目现在变得很大很复杂,因此 JIT 编译器需要花费较长时间才能热身完,而且有些 Java 方法还没法编译,性能方面也会下降.AoT 编译就是为了解决这些问题而生的.

在 JDK 9 中, AOT(JEP 295: Ahead-of-Time Compilation)作为实验特性被引入进来,开发者可以利用新的 jaotc 工具将重点代码转换成类似类库一样的文件.虽然仍处于试验阶段,但这个功能使得 Java 应用在被虚拟机启动之前能够先将 Java 类编译为原生代码.此功能旨在改进小型和大型应用程序的启动时间,同时对峰值性能的影响很小.
但是 Java 技术供应商 Excelsior 的营销总监 Dmitry Leskov 担心 AoT 编译技术不够成熟,希望 Oracle 能够等到 Java 10 时有个更稳定版本才发布.

另外 JVMCI (JEP 243: Java-Level JVM Compiler Interface) 等特性,对于整个编程语言的发展,可能都具有非常重要的意义,虽然未必引起了广泛关注.目前 Graal Core API 已经被集成进入 Java 9,虽然还只是初始一小步,但是完全用 Java 语言来实现的可靠的、高性能的动态编译器,似乎不再是遥不可及,这是 Java 虚拟机开发工程师的福音.

与此同时,随着 Truffle 框架和 Substrate VM 的发展,已经让个别信心满满的工程师高呼 "One VM to Rule Them All!" , 也许就在不远的将来 Ploygot 以一种另类的方式成为现实.

[[java-9-feature-ProcessHandle]]
== 进程 API

在 Java 5 之前，生成新进程的唯一方法是使用 `Runtime.getRuntime().exec()` 方法。 然后在 Java 5 中，引入了 `ProcessBuilder` API，它支持一种更简洁的方式来生成新进程。 现在，Java 9 添加了一种获取有关当前进程和任何衍生进程的信息的新方法。

要获取任何进程的信息，现在您应该使用 `java.lang.ProcessHandle.Info` 接口。 此接口可用于获取大量信息，例如

* 用于启动进程的命令
* 命令的参数
* 进程开始的时间
* 它和创建它的用户花费的总时间

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
include::{java-code}/java9/Process.java[tag=process1]
----

要获取新衍生进程的信息，请使用 `process.toHandle()` 方法获取 `ProcessHandle` 实例。其余的操作都和上面一样。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
include::{java-code}/java9/Process.java[tag=process2]
----

还使用 `ProcessHandle.allProcesses()` 获取系统中所有可用进程的 `ProcessHandle` 流。

要获取所有子进程的列表（直接以及 `n` 级深度），请使用 `children()` 和 `descendants()` 方法。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
include::{java-code}/java9/Process.java[tag=process3]
----

下面代码 中给出了进程 API 的使用示例.


[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
include::{java-code}/java9/Process.java[tag=process]
----

[[java-9-feature-loggerfinder]]
== 平台日志 API 和服务

JDK 9 通过新的日志记录 API 改进了平台类（JDK 类）和 JVM 组件中的日志记录。它允许您指定您选择的日志记录框架（例如 Log4J2）作为日志记录后端，用于记录来自 JDK 类的消息。关于这个 API，你应该知道几件事：

* API 旨在供 JDK 中的类使用，而不是由应用程序类使用。
* 对于您的应用程序代码，您将像以前一样继续使用其他日志记录 API。
* API 不允许您以编程方式配置 logger。

API 由以下部分组成：

* 一个服务接口，`java.lang.System.LoggerFinder`，它是一个抽象的静态类
* 一个接口，`java.lang.System.Logger`，它提供了日志 API
* `java.lang.System` 类中的一个重载方法 `getLogger()`，它返回一个记录器实例。

JDK 9 还添加了一个新的命令行选项 `-Xlog` ，它使您可以访问从 JVM 的所有类记录的所有消息。以下是使用 `-Xlog` 选项的语法：

[source,shell]
----
-Xlog[:][:[][:[][:]]]
----

所有选项都是可选的。 如果缺少 `-Xlog` 中的前一部分，则必须为该部分使用冒号。 例如，`-Xlog::stderr` 表示所有部分都是默认的，输出设置为 `stderr`。

[[java-9-feature-reactor]]
== 响应式流

响应式编程的思想最近得到了广泛的流行. 在 Java 平台上有流行的响应式库 `RxJava` 和 `Reactor`.响应式流规范的出发点是提供一个带非阻塞负压( non-blocking backpressure ) 的异步流处理规范.响应式流规范的核心接口已经添加到了 Java 9 中的 `java.util.concurrent.Flow` `类中.

`Flow` 中包含了 `Flow.Publisher`、`Flow.Subscriber`、`Flow.Subscription` 和 `Flow.Processor` 等 4 个核心接口.Java 9 还提供了 `SubmissionPublisher` 作为 `Flow.Publisher` 的一个实现.RxJava 2 和 `Reactor` 都可以很方便的 与 `Flow` 类的核心接口进行互操作.

[[java-9-feature-variable]]
== 变量句柄

变量句柄是一个变量或一组变量的引用,包括静态域,非静态域,数组元素和堆外数据结构中的组成部分等.变量句柄的含义类似于已有的方法句柄.变量句柄由 Java 类 `java.lang.invoke.VarHandle` 来表示.可以使用类 `java.lang.invoke.MethodHandles.Lookup` 中的静态工厂方法来创建 `VarHandle` 对象.
通过变量句柄,可以在变量上进行各种操作.这些操作称为访问模式.不同的访问模式尤其在内存排序上的不同语义.目前一共有 31 种 访问模式,而每种访问模式都 在 `VarHandle` 中 有对应的方法.
这些方法可以对变量进行读取、写入、原子更新、数值原子更新和比特位原子操作等.`VarHandle` 还可以用来访问数组中的单个元素,以及把 `byte[]` 数组 和 `ByteBuffer` 当成是不同原始类型的数组来访问.

=== 访问模式（Access Modes）
VarHandle 文档中定义了以下几种访问类别：plain、opaque、release/acquire、volatile。它们提供了由低到高的一致性保证级别：

* plain: 不确保内存可见性，opaque、release/acquire、volatile是可以保证内存可见的。
* opaque: 保证程序执行顺序，但不保证其它线程的可见顺序。
* release/acquire 保证程序执行顺序，`setRelease` 确保前面的 `load` 和 `store` 不会被重排序到后面，但不确保后面的 `load` 和 `store` 重排序到前面；`getAcquire` 确保后面的 `load` 和 `store` 不会被重排序到前面，但不确保前面的 load 和 `store` 被重排序。
* volatile: 确保程序执行顺序，且保证变量之间不被重排序。

VarHandle 定义了以下五种访问模式，结合上面的一致性保证级别，提供了超多的方法。

* Read access mode：get, getVolatile, getAcquire 和 getOpaque.
* Write access mode：set, setVolatile, setRelease 和 setOpaque.
* Atomic update access mode：compareAndSet, compareAndExchangeAcquire, compareAndExchange, compareAndExchangeRelease, getAndSet, getAndSetAcquire, getAndSetRelease, etc.
* Numeric atomic update access mode：getAndAdd, getAndAddAcquire, getAndAddRelease.
* Bitwise atomic update access mode：getAndBitwiseOr, getAndBitwiseOrAcquire, getAndBitwiseOrRelease, getAndBitwiseAnd, getAndBitwiseAndAcquire, getAndBitwiseAndRelease, getAndBitwiseXor, getAndBitwiseXorAcquire, getAndBitwiseXorRelease, etc.

在如下代码 中,我们创建了访问 `HandleTarget` 类中的域 `count` 的变量句柄,并在其上进行读取操作.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
include::{java-code}/java9/VarHandleTest.java[]
----

累加器实现：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 8
----
include::{java-code}/java9/CounterPlusWithJava8.java[]
----
[source,java,indent=0,subs="verbatim,quotes",role="secondary"]
.Java 9
----
include::{java-code}/java9/CounterPlusWithJava9.java[]
----

[[java-9-feature-method]]
== 改进方法句柄

类 `java.lang.invoke.MethodHandles` 增加了更多的静态方法来创建不同类型的方法句柄.

* arrayConstructor: 创建指定类型的数组.
* arrayLength: 获取指定类型的数组的大小.
* varHandleInvoker 和 varHandleExactInvoker: 调用 VarHandle 中的访问模式方法.
* zero: 返回一个类型的默认值.
* empty: 返 回 MethodType 的返回值类型的默认值.
* loop、countedLoop、iteratedLoop、whileLoop 和 doWhileLoop: 创建不同类型的循环,包括 `for` 循环、`while` 循环 和 `do-while` 循环.
* tryFinally: 把对方法句柄的调用封装在 try-finally 语句中.

在 下面代码中,我们使用 `iteratedLoop` 来创建一个遍历 String 类型迭代器的方法句柄,并计算所有字符串的长度的总和.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
include::{java-code}/java9/IteratedLoopTest.java[]
----

[[java-9-feature-concurrency]]
== 并发

在并发方面,类 `CompletableFuture` 中增加了几个新的方法.`completeAsync` 使用一个异步任务来获取结果并完成该 `CompletableFuture`. `orTimeout` 在 `CompletableFuture` 没有在给定的超时时间之前完成,使用 `TimeoutException` 异常来完成 `CompletableFuture`.
`completeOnTimeout` 与 `orTimeout` 类似,只不过它在超时时使用给定的值来完成 `CompletableFuture`.新的 `Thread.onSpinWait` 方法在当前线程需要使用忙循环来等待时,可以提高等待的效率.

[[java-9-feature-io]]
== I/O 流新特性

类 `java.io.InputStream` 中增加了新的方法来读取和复制 `InputStream` 中包含的数据.

* `readAllBytes`: 读取 `InputStream` 中的所有剩余字节.
* `readNBytes`:  从 `InputStream` 中读取指定数量的字节到数组中.
* `transferTo`: 读取 `InputStream` 中的全部字节并写入到指定的 `OutputStream` 中 .

如下代码中给出了这些新方法的使用示例.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
include::{java-code}/java9/TestInputStream.java[]
----

`ObjectInputFilter` 可以对 `ObjectInputStream` 中包含的内容进行检查,来确保其中包含的数据是合法的.可以使用 `ObjectInputStream` 的方法 `setObjectInputFilter` 来设置.`ObjectInputFilter` 在进行检查时,可以检查如对象图的最大深度、对象引用的最大数量、输入流中的最大字节数和数组的最大长度等限制,也可以对包含的类的名称进行限制.

[[java-9-feature-security]]
== 改进应用安全性能

Java 9 新增了 4 个 `SHA-3` 哈希算法,`SHA3-224`、`SHA3-256`、`SHA3-384` 和 `SHA3-512`.另外也增加了通过 `java.security.SecureRandom` 生成使用 `DRBG` 算法的强随机数. 如下代码中给出了 `SHA-3` 哈希算法的使用示例

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java 9
----
include::{java-code}/java9/SHA3.java[]
----

[[java-9-feature-desktop]]
== 用户界面

类 `java.awt.Desktop` 增加了新的与桌面进行互动的能力.可以使用 `addAppEventListener` 方法来添加不同应用事件的监听器,包括应用变为前台应用、应用隐藏或显示、屏幕和系统进入休眠与唤醒、以及 用户会话的开始和终止等.
还可以在显示关于窗口和配置窗口时,添加自定义的逻辑.在用户要求退出应用时,可以通过自定义处理器来接受或拒绝退出请求.在 AWT 图像支持方面,可以在应用中使用多分辨率图像.

[[java-9-feature-deprecation]]
== Deprecated 的相关 API

[[java-9-feature-deprecation-feature]]
=== 官方 Feature

* 211: Elide Deprecation Warnings on Import Statements
* 214: Remove GC Combinations Deprecated in JDK 8
* 277: Enhanced Deprecation
* 289: Deprecate the Applet API
* 291: Deprecate the Concurrent Mark Sweep (CMS) Garbage Collector

Java 9 废弃或者移除了几个不常用的功能.其中最主要的是 `Applet` API,现在是标记为废弃的.随着对安全要求的提高,主流浏览器已经取消对 Java 浏览器插件的支持.HTML5 的出现也进一步加速了它的消亡.
开发者现在可以使用像 Java Web Start 这样的技术来代替 `Applet`,它可以实现从浏览器启动应用程序或者安装应用程序.同时,`appletviewer` 工具也被标记为废弃.
