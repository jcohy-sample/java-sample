[[java-18-feature]]
= Java 18 新特性

[[java-18-feature-overview]]
== Java 18 新特性一览

2022 年 3 月 22 日,JDK/Java 18 正式 GA(General Available) 正式发布.

Java 18 为用户提供了 9 项主要的 JEP (Java/JDK Enhancement Proposals,JDK 增强提案)，包括两个孵化器模块，一个预览功能

资料来源:  http://openjdk.java.net/projects/jdk/18/

[[java-18-feature-overview-tbl]]
.Java 18 新特性一览
|===
| 新特性 | 翻译

| 400: https://openjdk.java.net/jeps/400[UTF-8 by Default] | 默认 UTF-8

| 408: https://openjdk.java.net/jeps/408[Simple Web Server] | 简单 Web 服务器

| 413: https://openjdk.java.net/jeps/413[Code Snippets in Java API Documentation] | 简化文档代码片段

| 416 https://openjdk.java.net/jeps/416[Reimplement Core Reflection with Method Handles] | 重新实现反射核心机制

| 417: https://openjdk.java.net/jeps/417[Vector API (Third Incubator)] | 矢量 API（三次孵化中）

| 418: http://openjdk.java.net/jeps/418[Internet-Address Resolution SPI] | 互联网地址解析 SPI

| 419: http://openjdk.java.net/jeps/419[Foreign Function & Memory API (Second Incubator)] | 外部函数和内存 API（二次孵化中）

| 420: http://openjdk.java.net/jeps/420[Pattern Matching for switch (Second Preview)] | switch 模式匹配（二次预览中）

| 421: http://openjdk.java.net/jeps/421[Deprecate Finalization for Removal] | 弃用 Finalization
|===

[[java-18-feature-environment]]
== 环境安装

* JDK 下载地址:
+
OpenJDK版本: https://jdk.java.net/18/
+
Oracle版本: https://www.oracle.com/java/technologies/javase/jdk18-archive-downloads.html

* 修改环境变量.

[[java-18-feature-default]]
==  默认 UTF-8

在 JDK 17 及更早版本中，默认字符集是在 Java 虚拟机运行时才确定的，取决于不同的操作系统、区域设置等因素，因此存在潜在的风险。

从这个版本开始，依赖于默认字符集的 API 会在所有实现、操作系统、语言环境和配置中保持一致。

可以使用以下命令查看当前 JDK 的默认字符集：

[source,java]
----
java -XshowSettings:properties -version 2>&1 | grep file.encoding
    file.encoding = UTF-8
    file.encoding.pkg = sun.io
----

在 JDK 中通过下面 API 获取当前 JDK 的默认字符集：

[source,java]
----
Charset.defaultCharset()
----

[[java-18-feature-web]]
== 简单的 Web 服务器

提供命令行工具来启动仅提供静态文件的最小 Web 服务器。 没有可用的 CGI 或类似 servlet 的功能。 该工具可用于原型设计、临时编码和测试目的，尤其是在教育环境中。

Simple Web Server 是用于服务单个目录层次结构的最小 HTTP 服务器。 它基于自 2006 年起包含在 JDK 中的 `com.sun.net.httpserver` 包中的 Web 服务器实现。该包得到官方支持，我们使用 API 对其进行了扩展，以简化服务器创建并增强请求处理。 Simple Web Server 可以通过专用的命令行工具 jwebserver 或通过其 API 以编程方式使用。

[[java-18-feature-web-command]]
=== 通过命令行工具

以下命令启动简单 Web 服务器：

[source,shell]
----
jwebserver
----

如果启动成功，那么 jwebserver 会向 System.out 打印一条消息，列出本地地址和所服务目录的绝对路径。例如：

[java,shell]
----
D:\Jdk\jdk-18.0.1.1\bin>jwebserver
Binding to loopback by default. For all interfaces use "-b 0.0.0.0" or "-b ::".
Serving D:\Jdk\jdk-18.0.1.1\bin and subdirectories on 127.0.0.1 port 8000
URL http://127.0.0.1:8000/
----

.jwebserver 选项
|===
|选项 |描述

| -h or -? or --help
| Prints the help message and exits.

| -b addr or --bind-address addr
| Specifies the address to bind to.  Default: 127.0.0.1 or ::1 (loopback).  For
all interfaces use -b 0.0.0.0 or -b ::.

| -d dir or --directory dir
| Specifies the directory to serve.  Default: current directory

| -o level or --output level
| Specifies the output format.  none | info | verbose.  Default: info

| -p port or --port port
| Specifies the port to listen on.  Default: 8000.

| -version or --version
|  Prints the version information and exits.
|===


默认情况下，服务器在运行并绑定到本地回环地址(127.0.0.1)和端口8000。这可以通过 `-b` 和 `-p` 选项进行更改。例如，要在端口  `9000` 上运行服务器，请使用：

[source,shell]
----
D:\Jdk\jdk-18.0.1.1\bin>jwebserver  -p 9000
Binding to loopback by default. For all interfaces use "-b 0.0.0.0" or "-b ::".
Serving D:\Jdk\jdk-18.0.1.1\bin and subdirectories on 127.0.0.1 port 9000
URL http://127.0.0.1:9000/
----

例如： 绑定服务器到所有接口：

[source,shell]
----
D:\Jdk\jdk-18.0.1.1\bin>jwebserver -b 0.0.0.0
Serving D:\Jdk\jdk-18.0.1.1\bin and subdirectories on 0.0.0.0 (all interfaces) port 8000
URL http://192.168.11.117:8000/
----

使用 `-d` 选项指定目录

[source,shell]
----
D:\Jdk\jdk-18.0.1.1\bin>jwebserver  -d E:\picture
Binding to loopback by default. For all interfaces use "-b 0.0.0.0" or "-b ::".
Serving E:\picture and subdirectories on 127.0.0.1 port 8000
URL http://127.0.0.1:8000/
----

仅提供具有幂等性的 `HEAD` 和 `GET` 请求。任何其他请求都会收到 501 - Not Implemented 或 405 - Not Allowed 响应。  · 请求映射到正在服务的目录，如下所示：

. 如果请求的资源是文件，则提供文件内容。
. 如果请求的资源是目录，则提供文件索引。
. 否则，将列出该目录的所有文件和子目录的名称。 未列出符号链接和隐藏文件。

Simple Web Server 仅支持 HTTP/1.1。 不支持 HTTPS 。

MIME 类型是自动配置的。 例如，`.html` 文件作为 `text/html` 提供，`.java` 文件作为 `text/plain` 提供。

默认情况下，每个请求都记录在控制台上。 输出如下所示：

[source,text]
----
127.0.0.1 - - [10/Feb/2021:14:34:11 +0000] "GET /some/subdirectory/ HTTP/1.1" 200 -
----

可以使用 `-o` 选项更改日志记录输出。 默认设置是 info。 详细设置还包括请求和响应标头以及所请求资源的绝对路径。

成功启动后，服务器将一直运行，直到停止。 在 Unix 平台上，可以通过向服务器发送 `SIGINT` 信号（在终端窗口中按 `Ctrl+C`）来停止服务器。

`-h` 选项显示一条帮助消息，列出所有选项，这些选项遵循 https://openjdk.org/jeps/293[JEP 293] 中的指南。还提供了 jwebserver 手册页。

[[java-18-feature-web-api]]
=== API

虽然命令行工具很有用，但如果想将 Simple Web Server 的组件（即服务器、处理程序和过滤器）与现有代码一起使用，或者进一步自定义处理程序的行为，该怎么办？ 虽然可以在命令行上进行一些配置，但是如果使用简单名了的编程式解决方案将提高服务器组件的实用性。 为了弥补命令行工具的简单性和当前 `com.sun.net.httpserver` API 的自己编写方法之间的差距，Java 18 定义了用于创建和定制服务器请求处理的新 API。

新类是 `SimpleFileServer`、`HttpHandlers` 和 `Request`，每个类都建立在 `com.sun.net.httpserver` 包中的现有类和接口之上：`HttpServer`、`HttpHandler`、`Filter` 和 `HttpExchange`。

`SimpleFileServer` 类支持创建文件服务器、文件服务器处理程序和输出过滤器：

[source,java]
----
package com.sun.net.httpserver;

public final class SimpleFileServer {
    public static HttpServer createFileServer(InetSocketAddress addr,
                                              Path rootDirectory,
                                              OutputLevel outputLevel) {...}
    public static HttpHandler createFileHandler(Path rootDirectory) {...}
    public static Filter createOutputFilter(OutputStream out,
                                            OutputLevel outputLevel) {...}
    ...
}
----

使用这个类，可以使用几行代码启动一个最小但自定义的服务器：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
include::{java-code}/java18/web/SimpleFileServerTest.java[tag=serve1]
----

将自定义 Handler 添加到服务器

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
include::{java-code}/java18/web/SimpleFileServerWithHandlerTest.java[tag=serve2]
----

添加自定义过滤输出到服务器

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
include::{java-code}/java18/web/SimpleFileServerWithFilterTest.java[tag=serve3]
----

[[java-18-feature-web-api-enhanced]]
==== 增强 request handling

Simple Web Server 的核心功能由其 handler  提供。 为了支持扩展此 handler 以与现有代码一起使用，我们引入了一个新的 `HttpHandlers` 类，该类具有两个用于 handler 创建和自定义的静态方法，以及一个用于适应请求的 Filter 类中的新方法：

[source,java]
----
package com.sun.net.httpserver;

public final class HttpHandlers {
    public static HttpHandler handleOrElse(Predicate<Request> handlerTest,
                                           HttpHandler handler,
                                           HttpHandler fallbackHandler) {...}
    public static HttpHandler of(int statusCode, Headers headers, String body) {...}
    {...}
}

public abstract class Filter {
    public static Filter adaptRequest(String description,
                                      UnaryOperator<Request> requestOperator) {...}
    {...}
}
----

`handleOrElse` 用另一个 handler 补充了条件处理程序，而工厂方法允许您创建具有预响应状态的 handler。 从 `adaptRequest` 获得的预处理过滤器可用于在处理请求之前检查和调整请求的某些属性。 这些方法的用例包括基于请求方法委托交换、创建始终返回特定响应的 "canned response" handler，或向所有传入的请求添加请求头。

现有 API 将 HTTP 请求捕获为由 `HttpExchange` 类的实例，表示请求-响应的一部分，该实例描述了交换的完整和可变状态。 并非所有的状态都对定制 handler 有意义。 因此，我们引入了一个更简单的 Request 接口来提供不可变请求状态的有限视图：

[source,java]
----
public interface Request {
    URI getRequestURI();
    String getRequestMethod();
    Headers getRequestHeaders();
    default Request with(String headerName, List<String> headerValues)
    {...}
}
----

现在，我们可以自定义已存在的 handler

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
include::{java-code}/java18/web/CustomizationHandler.java[]
----

[[java-18-feature-snippet]]
==  Java API 文档中支持 Snippets 代码片段

为 JavaDoc 的标准 Doclet 引入一个 `@snippet` 标签，以简化在 API 文档中包含示例源代码。

他可以用来声明内联片段（代码片段在标签内部）和外部片段（代码片段从单独的源文件读取）

`snippet` 的其他详细信息可以使用 `name=value` 的键值对形式，放置在  initial tag 之后，name 是一个简单的标识符，属性值可以使用单引号或双引号括起来，不支持转义字符。属性之间以空白符分隔，例如空格或换行符

`snippet` 可以指定一个 `id` 属性，该属性可以在 API 和生成的 HTML 文件中标识代码片段，并创建锚链接。在生成的 HTML 中，`id` 将放置在生成的最外层元素上以表示片段。

代码片段通常是 Java 源代码，但它们也可能是属性文件的片段、其他语言的源代码或纯文本。 snippet  可以指定一个 `lang` 属性，该属性标识代码片段的内容类型。 对于内联代码，默认值为 `java`。 对于外部片段，默认值为包含片段内容的文件名的扩展名。

在代码片段中，`markup` 标签可以放置在行注释中以识别文本中的区域并指示如何呈现文本。 （我们将在下面看到 `markup` 标签的示例，例如 `@highlight` 和 `@replace`。）

[[java-18-feature-snippet-inline]]
===  内联片段

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
include::{java-code}/java18/web/SnippetsTest.java[tag=snippet]
----

生成的代码片段为冒号之后的换行符和右大括号之间的文本, 不需要去转义 HTML  `<`, `>`, 和 `&` 这类字符，也不用转义文档的注释标签。

生成的文档使用了 `String::stripIndent` 去除了内容前面的空格，与 `<pre>{@code ...}</pre>` 不同，这个显示的文本总是在空格和星号之后才开始。而在 snippet 中，生成的文本块的内容的位置是相对于源文件中右大括号的位置进行缩进。上面的例子生成的文档如下：

image::{oss-images}/java18-snippet1.png[]

内联代码段的内容有两个限制：

* 内联的代码片段不能使用  /* ... */ 注释，因为 */ 会终止整个文档的注释
* 内联的代码片段的大括号要成对出现，即整个内联标签由与左大括号匹配的第一个右大括号终止。

尽管有这些限制，但当示例代码很短、不需要 IDE 中的语言级编辑支持并且不需要与文档中其他地方的其他代码段共享时，内联代码片段很方便。

[[java-18-feature-snippet-external]]
===  外部片段

外部片段是指包含片段内容的单独文件。

在外部代码段中，可以省略冒号、换行符和后续内容。

让我们重写上面的实例，使用外部代码片段：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
include::{java-code}/java18/web/SnippetsTest.java[tag=snippet2]
----

`file` 属性值为文件的名称，`region` 属性表示要显示的区域。有关 `@start` 和 `@end` 标签的更多信息，请参考 <<java-18-feature-snippet-region>>

在此示例中，输出和上面的一样：

image::{oss-images}/java18-snippet2.png[]

与内联片段不同，外部片段对其内容没有限制。 特别是，它们可能包含 /* ... */ 注释。

外部代码的位置可以通过 `class` 属性指定类名或者通过 `file` 属性指定文件相对位置来引入。不管是哪种情况，文件都放在当前包目录下的 `snippet-files` 子目录中，该目录包含带有 {@snippet ...} 标签的源代码。
另外，你也可以将文件放在辅助搜索目录，使用 `javadoc` 的 `--snippet-path` 选项指定

外部代码片段可能包含多个 region，这些 region 可能会在不同的代码片段中引用。

外部代码片段很有用，这样我们就可以将示例代码编写为单独的文件，并且可以直接在 IDE 中编辑，代码之间还可以共享。`snippet-files` 目录中的文件可以在同一包中的代码片段之间共享，并且与其他包中的 `snippet-files` 目录中的代码片段隔离。辅助搜索路径上的文件存在于单个共享名称空间中，并且可以从文档中的任何位置引用。

[[java-18-feature-snippet-hybrid]]
===  Hybrid snippets（混合代码片段）

混合片段是又有内部片段又有外部片段。 它包含 snippet 本身内的片段内容，以方便任何人阅读正在记录的类的源代码，它还引用包含片段内容的单独文件。

如果将混合代码片段作为内联代码段处理的结果与将其作为外部代码段处理的结果不匹配，则会出现错误。

[[java-18-feature-snippet-markup]]
===  Markup tags（标记标签）

标记标签定义片段内容中的区域。 它们还控制内容的呈现方式，例如突出显示部分文本、修改文本或链接到文档中的其他位置。 它们可用于内部、外部和混合片段。

标记标签以 `@name` 开头，后跟任何必需的参数。它们被放置在 `//` 注释中（或其他语言与之等价的注解中），以免过度干扰源代码的主体，也因为 `/* ... */` 注释不能在内联代码段中使用。这样的注释被称为标记注释。

多个标记标签可以放置在同一个标记注释中。标记标记应用于包含注释的源代码行，除非注释以冒号 (:) 结尾，在这种情况下标记标记仅应用于以下行。如果标记注释特别长，或者片段内容的句法格式不允许注释与非注释源出现在同一行，则后一种语法可能很有用。标记注释不会出现在生成的输出中。

因为其他一些系统使用类似于标记注释的元注释，所以以 `@` 开头后跟无法识别的名称的注释将被忽略。如果名称被识别，但标记注释中有后续错误，则报告错误。在这种情况下生成的输出相对于从代码片段生成的输出是未定义的。

[[java-18-feature-snippet-region]]
=== Regions（区域）

区域主要用于标识要由 snippet 显示的文本。 它们还定义了突出显示或修改文本等操作的范围。

区域由以下任一标签开始

* @start region=name, 或者
* @highlight, @replace, 或者 @link 指定 region 或者使用 region=name. 如果匹配的 `@end` 标签不需要该名称，则可以省略该名称。

region 的结束由 `@end` 或 `@end region=name` 标记。 如果给定名称，则结束以该标签名称开头的区域。 如果没有给出名称，则结束最近开始的没有匹配的 `@end` 标签的区域。

由不同的匹配 `@start` 和 `@end` 标签对创建的区域没有限制。region 甚至可以重叠，尽管我们不希望这种用法很普遍。

[[java-18-feature-snippet-highlighting]]
=== Highlighting（高亮）

要突出显示内容，请使用 `@highlight` 后跟参数，这些参数指定文本范围、突出显示的文本以及突出显示的类型。

如果指定了 `region` 或 `region=name`，则范围是该区域，直到对应的 `@end` 标记。否则，突出显示的范围只是当前行。

如果要突出显示范围内指定的字符串，请使用 `substring=string` 指定字符串，其中 `string` 可以是标识符或用单引号或双引号括起来的文本。要突出显示范围内正则表达式匹配的每个文本实例，请使用 `regex=string`。如果这些属性都没有指定，那么整个范围都会突出显示。

可以使用 `type` 参数指定突出显示的类型。有效的类型名称为  bold（粗体）, italic（斜体）, 和 highlighted（突出显示）。类型的名称将转换为 CSS 类名称，其属性可以在系统样式表中定义或在用户定义的样式表中覆盖。

例如，这里是如何使用 `@highlight` 标记来强调使用特定方法名称的方法：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
include::{java-code}/java18/web/SnippetsTest.java[tag=snippet3]
----

输出为：

image::{oss-images}/java18-snippet3.png[]

下面的示例使用正则高亮显示一行中的 `arg`

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
include::{java-code}/java18/web/SnippetsTest.java[tag=snippet4]
----

输出为：

image::{oss-images}/java18-snippet4.png[]

[[java-18-feature-snippet-modifying]]
=== 修改显示的文本

有时间，我们可能需要使用省略号来替换一些说明性的文档。这时，我们可以使用 `@replace` 来完成。

要替换文本，请使用 `@replace` 后跟参数，这些参数指定文本的范围、要替换的文本以及替换文本。

如果指定了 `region` 或 `region=name`，则范围是该区域，直到对应的 `@end` 标记。否则，范围只是当前行。

要替换范围内的文字字符，请使用 `substring=string` 指定字符串，其中字符串可以是标识符或用单引号或双引号括起来的文本。要替换范围内与正则表达式匹配的每个文本实例，请使用 `regex=string`。如果没有指定这些属性，则替换整个范围。

使用替换参数指定替换文本。如果使用正则表达式指定要替换的文本，则可以使用 `$number` 或 `$name` 替换在正则表达式中找到的组，如 `String::replaceAll` 所定义。

例如，这里是如何用省略号替换 `println` 调用的参数：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
include::{java-code}/java18/web/SnippetsTest.java[tag=snippet5]
----

输出为：

image::{oss-images}/java18-snippet5.png[]

[NOTE]
====
要删除文本，请使用 `@replace=""` 的  `@replace`, 要插入文本，请使用 `@replace`  的 `replace` 后跟 no-op text （无操作文本）， `replacement` 的值被插入，无操作文本可能为 `//` 标记或者空语句(`;`)
====

[[java-18-feature-snippet-link]]
=== 文本链接

要将文本链接到 API 中其他声明的位置，请使用 `@link` 后跟参数，这些参数指定文本范围、要链接的文本以及链接的目标。

如果指定了 `region` 或 `region=name`，则范围是该区域，直到对应的 `@end` 标签。 否则，范围只是当前行。

要链接范围内文字字符串的每个实例，请使用 `substring=string` 指定字符串，其中字符串可以是标识符或用单引号或双引号括起来的文本。 要链接范围内正则表达式匹配的每个文本实例，请使用 `regex=string`。 如果没有指定这些属性，则链接整个范围。

使用 `target` 参数指定目标。 其值的形式与标准内联 `{@link ...}` 标签所使用的形式相同。

例如，下面是如何将文本 `System.out` 链接到它的声明：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
include::{java-code}/java18/web/SnippetsTest.java[tag=snippet6]
----

输出为：

image::{oss-images}/java18-snippet6.png[]

[[java-18-feature-snippet-file]]
=== 其他类型的文件

前面部分中的示例显示了 Java 源代码的片段，但也支持其他类型的文件，例如属性文件。 与 Java 源代码完全相同，属性文件格式的代码片段可以使用内联代码片段，并且可以使用 `file` 属性在外部代码片段中指定属性文件。

这是一个包含 `.properties` 文件的全部内容的外部代码段：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
include::{java-code}/java18/web/SnippetsTest.java[tag=snippet7]
----

在属性文件中，注释是以井号 (#)  字符开头的行。 因为一些标记标签的默认范围是当前行，并且由于属性文件不允许注释与非注释内容放在同一行，所以可能需要使用以 `:` 结尾的标记注释的形式，以便标记注释被视为适用于以下行。

这是一个定义一些属性的片段，突出显示了第二个属性的值：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
include::{java-code}/java18/web/SnippetsTest.java[tag=snippet8]
----

[[java-18-feature-snippet-reference]]
=== Snippet tag reference

Attributes for the {@snippet} tag::
* class — a class containing the content for the snippet
* file — a file containing the content for the snippet
* id — an identifier for the snippet, to identify the snippet in the generated documentation
* lang — the language or format for the snippet
* region — the name of a region in the content to be displayed

Markup tags, to appear in markup comments::
* start — mark the beginning of a region
** region — the name of the region
* end — mark the end of a region
** region — the name of the region; can be omitted for an anonymous region
* highlight — highlight text within a line or region
** substring — the literal text to be highlighted
** regex — a regular expression for the text to be highlighted
** region — a region to define the scope in which to find the text to be highlighted
** type — the type of highlighting, such as bold, italic, or highlighted
* replace — replace text within a line or region
** substring — the literal text to be replaced
** regex — a regular expression for the text to be replaced
** region — a region to define the scope in which to find the text to be highlighted
** replacement — the replacement text
* link — link text within a line or region
** substring — the literal text to be replaced
** regex — a regular expression for the text to be replaced
** region — a region to define the scope in which to find the text to be highlighted
** target — the target of the link, expressed in one of the forms suitable for an {@link ...} tag
** type — the type of link: one of link (the default) or linkplain

[[java-18-feature-reimplement]]
==  重新实现反射核心机制

JDK 18 使 Method Handles 作为反射的底层机制，重新实现了 `Method::invoke`、`Constructor::newInstance`、`Field::get` 和 `Field::set` 组件，将大大降低反射 API 的维护和开发成本。

新实现直接调用反射对象的方法句柄。我们仅在早期 VM 启动期间使用 VM 的本机反射机制，在初始化方法句柄机制之前。这会在 `System::initPhase1` 之后和  `System::initPhase2` 之前发生，之后我们切换到独占使用方法句柄。这通过减少本机堆栈帧的使用使 Project Loom 受益。

为获得最佳性能，`Method`、`Constructor` 和 `Field` 实例应保存在静态 final 字段中，以便 JIT 可以对它们进行 constant-folded。完成后，微基准测试显示新实现的性能明显比旧实现快了 43-57%。

当 `Method`、`Constructor` 和 `Field` 实例保存在非常量字段中时（例如，在非 final 字段或数组元素中），微基准测试会有一些性能下降。当 `Field` 实例不能被 constant-folded 时，字段访问的性能明显比旧实现慢 51-77%。

但是，这种降级可能不会对实际应用程序的性能产生太大影响。我们使用真实世界的库运行了几个序列化和反序列化基准测试，发现没有降级

[[java-18-feature-vector]]
==  矢量 API（三次孵化中）

[[java-18-feature-vector-summary]]
=== 简介

该孵化器 API 提供了一个 `jdk.incubator.vector` 的初始迭代以表达一些矢量计算，用于表示在运行时可靠地编译到支持的 CPU 架构上的最佳矢量硬件指令的矢量计算，矢量运算可以提供优于等效标量计算的性能

Vector API 最初由 https://openjdk.org/jeps/338[JEP 338] 提出，并作为孵化 API 集成到 Java 16 中。 第二轮孵化由 https://openjdk.org/jeps/414[JEP 414] 提出并集成到 Java 17 中。

此版本中主要包括以下变化：

* 支持 ARM 标量矢量扩展 (SVE) 平台。
* 在支持硬件掩码的架构上提高接受掩码的向量操作的性能。

[[java-18-feature-internet]]
== 互联网地址解析 SPI

定义了一个全新的 SPI（service-provider interface），用于主要名称和地址的解析，以便 java.net.InetAddress 可以使用平台之外的第三方解析器。

[[java-18-feature-memory]]
== 外部函数和内存 API（孵化器）

引入一个 API，通过有效调用外部函数（即 JVM 外部的代码）和安全地访问外部内存（即不由 JVM 处理的内存），允许 Java 程序调用本地库和处理本地数据而没有 JNI 的风险.

在这个 JEP 提案中，是早期两个孵化 API 的演变：外部内存访问 API 和外部链接器 API。外部内存访问 API 首先由 JEP 370 提出，并于 2019 年底作为 Java 14 的一个孵化 API，它被 Java 15 中的 JEP 383 和 Java 16 中的 JEP 393 重新孵化。Foreign Linker API 最初是由 JEP 389 提出的，目标是在 2020 年底的 Java 16，也是一个孵化 API。

[[java-18-feature-memory-goals]]
=== 目标

易用性：用 Java 本机接口 (JNI) 替换卓越的纯 Java 开发模型。

性能：与现有 API（如 JNI 或 sun.misc.Unsafe）相似的性能，如果不是更好的话。表现。

常规：提供了在各种类型的外部内存（例如，本机内存、持久内存和堆内存）上工作的方法，并随着时间的推移适应其他平台（例如，x86 32 位）和用 C 以外的语言编写的外部函数（例如，C++、FORTAN）。

安全：仅当应用程序开发人员或最终用户明确选择加入时，才停用默认的不安全操作。

[[java-18-feature-switch]]
== switch 模式匹配（二次预览中）

通过对 Switch 表达式和语句的模式匹配以及对模式语言的扩展来增强 Java 编程语言。允许针对各种模式验证 switch 表达式和语句，每个模式都有不同的操作。这使得以简单和安全的方式表达复杂的面向数据的查询成为可能。

[[java-18-feature-switch-goals]]
=== 目标

* 允许模式出现在 case 语句中，扩展 switch 表达式和语句的表达性和适用性。
* 如果需要，让历史转折点的零敌意放松。
* 将引入两种新模式：:保护模式，使用任意布尔表达式来优化模式匹配逻辑，以及带括号的模式：清除解析歧义。
* 确保所有现有的 switch 表达式和语句都使用相同的语义进行编译，并在不做任何修改的情况下执行它们。
* 不要引入与传统 switch 结构分离的模式匹配语义的新的类似于 switch 的表达式或语句。
* 当 case 标签是模式时，不要使 switch 表达式或语句的行为与 case 标签是传统常量时不同。

[[java-18-feature-switch-motivation]]
=== 动机

在 Java 16 中，https://openjdk.java.net/jeps/394[JEP 394] 扩展了 instanceof 操作符，以接受类型模式并执行模式匹配。这个扩展可以简化熟悉的实例和转换习惯用法:

[source,java]
----
// Old code
if (o instanceof String) {
    String s = (String)o;
    ... use s ...
}

// New code
if (o instanceof String s) {
    ... use s ...
}
----

我们经常希望可以将一个变量(如 o )与多个选项进行比较。Java 支持使用 switch 语句进行多路比较，并且从 Java 14 开始，支持 switch 表达式(https://openjdk.java.net/jeps/361[JEP 361])，但不幸的是 switch 非常有限。您只能对 numeric 类型、enum 类型和 String 类型进行比较，并且只能测试常量的相等性。我们可能希望使用模式来针对多个可能性测试相同的变量，对每个可能性采取特定的操作，但由于现有的 switch 不支持这种操作，我们最终会得到一个 if...else 链，如:

[source,java]
----
static String formatter(Object o) {
    String formatted = "unknown";
    if (o instanceof Integer i) {
        formatted = String.format("int %d", i);
    } else if (o instanceof Long l) {
        formatted = String.format("long %d", l);
    } else if (o instanceof Double d) {
        formatted = String.format("double %f", d);
    } else if (o instanceof String s) {
        formatted = String.format("String %s", s);
    }
    return formatted;
}
----

这段代码受益于使用 instanceof 表达式，但它并不完美。首先，这种方法可能隐藏了错误的编码，因为我们使用了这种控制结构。目的是在  if...else 的每个分支中为 formatted 赋值。但是没有任何东西使编译器能够识别和验证不变性。如果某些分支 - 也许很少执行的分支 - 没有分配给 formatted，那么就会出现错误。(将 formatted 声明为空的局部变量至少会在此工作中获得编译器的确定赋值分析，但这样的声明并不总是可以编写的。)此外，上面的代码是不可优化的，它的时间复杂度将为O(n)，尽管潜在的问题通常是O(1)。

但是 switch 是一个完美的用来进行匹配的模式匹配!如果我们将 switch 语句和表达式扩展到任何类型，并且允许 case 标签使用模式而不仅仅是常量，那么我们就可以更清晰、更可靠地重写上面的代码:

[source,java]
----
static String formatterPatternSwitch(Object o) {
    return switch (o) {
        case Integer i -> String.format("int %d", i);
        case Long l    -> String.format("long %d", l);
        case Double d  -> String.format("double %f", d);
        case String s  -> String.format("String %s", s);
        default        -> o.toString();
    };
}
----

这个 switch 的语义很清楚:带有模式的 case 标签匹配选择表达式 o 的值，如果该值与模式匹配。(为了简洁起见，我们已经演示了一个 switch 表达式，但本可以演示一个 switch 语句;switch 块，包括 case 标签，将保持不变。)

这段代码的目的更清晰，因为我们使用了正确的控制结构:我们说，"参数 o 最多匹配以下条件之一，找出它并计算相应的分支。"，并且它是可优化的;在这种情况下，我们更有可能在 O(1) 时间内执行完成。

[[java-18-feature-switch-null]]
=== 模式匹配和 null 值

通常，switch 语句和表达式在选择表达式的值为 `null` 时抛出 `NullPointerException`，所以 `null` 的测试必须在 `switch` 之外进行:

[source,java]
----
static void testFooBar(String s) {
    if (s == null) {
        System.out.println("oops!");
        return;
    }
    switch (s) {
        case "Foo", "Bar" -> System.out.println("Great");
        default           -> System.out.println("Ok");
    }
}
----

当 switch 只支持少数引用类型时，这是合理的。但是，如果 switch 允许任何类型的选择表达式，并且 case 标签可以有类型模式，那么单独的 `null` 测试感觉就很随意，并且有可能带来不必要的错误。最好将 `null` 测试集成到 switch 中:

[source,java]
----
static void testFooBar(String s) {
    switch (s) {
        case null         -> System.out.println("Oops");
        case "Foo", "Bar" -> System.out.println("Great");
        default           -> System.out.println("Ok");
    }
}
----

当选择器表达式的值为 `null` 时，switch 的行为由它的 case 标签决定的。case 为 `null`(或 total 类型模式;参见下面的 <<java-18-feature-switch-description-switch-null-matching,4a>>) switch 执行与该标签相关联的代码;如果 case 没有 `null`，switch 会抛出 `NullPointerException`，就像之前一样。(为了保持与 switch 当前语义的向后兼容性，默认标签不匹配 `null` 选择器。)

我们可能希望以与另一个 case 标签相同的方式处理 `null`。例如，在下面的代码中，case `null`, String s 将匹配 null 值和所有的String 值:

[source,java]
----
static void testStringOrNull(Object o) {
    switch (o) {
        case null, String s -> System.out.println("String: " + s);
    }
}
----

[[java-18-feature-switch-refining]]
=== switch 模式改进

在 switch 中对模式的试验表明，想要改进模式是很常见的。考虑以下转换 `Shape` 值的代码:

[source,java]
----
class Shape {}
class Rectangle extends Shape {}
class Triangle  extends Shape { int calculateArea() { ... } }

static void testTriangle(Shape s) {
    switch (s) {
        case null:
            break;
        case Triangle t:
            if (t.calculateArea() > 100) {
                System.out.println("Large triangle");
                break;
            }
        default:
            System.out.println("A shape, possibly a small triangle");
    }
}
----

这段代码为三角形面积大于 100 进行特殊处理，其他的提供一种默认行为。我们不能直接使用单个条件来表示这一点，所有，我们首先要编写一个 case 语句来匹配所有的三角形，然后将三角形面积的判断放在相应的语句中，然后，当三角形面积小于 100 时，我们使用 fall-through 机制获取正确的行为（请注意，break 语句在 if 内）

这里的问题是，只判断一种情况不能使用一条语句。所有，我们需要某种方式对模式进行细化。一种方法可能是允许对 case 语句进行细化;这种改进在其他编程语言中称为 guard 。例如，我们可以引入一个新的关键字，出现在 case 语句的末尾，后面跟一个布尔表达式，例如，`case Triangle t where t.calculateArea() > 100`。

然而，还有一种更具表现力的方法。我们可以扩展模式本身的语言，而不是扩展 case 语句的功能。我们可以添加一种新的模式，称为 guarded pattern（保护模式）(例如 p && b,)，它允许 p 被任意布尔表达式 b 匹配

使用这种方法，我们可以重新编写 `testTriangle` 代码，直接表达大三角形的特殊情况。这就消除了 switch 语句中 fall-through 的使用，这意味着我们可以享受简洁的箭头风格(->)规则:

[source,java]
----
static void testTriangle(Shape s) {
    switch (s) {
        case Triangle t && (t.calculateArea() > 100) ->
            System.out.println("Large triangle");
        default ->
            System.out.println("A shape, possibly a small triangle");
    }
}
----

s 的值匹配 Triangle t && (t.calculateArea() > 100)，首先，它匹配类型 Triangle t，如果是，表达式 `t.calculateArea() > 100` 的计算结果为 `true`。

使用 Switch 可以轻松的更改需求变更时的 case 语句 。例如，我们可能想要将三角形从默认路径中分离出来;如下:

[source,java]
----
static void testTriangle(Shape s) {
    switch (s) {
        case Triangle t && (t.calculateArea() > 100) ->
            System.out.println("Large triangle");
        case Triangle t ->
            System.out.println("Small triangle");
        default ->
            System.out.println("Non-triangle");
    }
}
----

[[java-18-feature-switch-description]]
=== 描述

我们用两种方式增强 switch 语句和表达式

* 扩展 case 语句以包括常量之外的模式
* 介绍两种新的模式:保护模式和括号模式

[[java-18-feature-switch-description-switch]]
==== switch 语句模式

引入一个新的 case p switch 语句，其中 p 是一个模式。但是，switch 的本质没有改变:选择器表达式的值与 switch 语句进行比较，选择其中一个标签，并执行与该标签相关的代码。现在的区别是，对于带有模式的 case 语句，是由模式匹配决定的，而不是由等式检查决定的。例如，在下面的代码中，o 的值匹配模式 Long l，与 case Long l 关联的代码将被执行:

[source,java]
----
Object o = 123L;
String formatted = switch (o) {
    case Integer i -> String.format("int %d", i);
    case Long l    -> String.format("long %d", l);
    case Double d  -> String.format("double %f", d);
    case String s  -> String.format("String %s", s);
    default        -> o.toString();
};
----

当 case 语句可以使模式时，有四个主要的设计问题:

. 增强类型检查
. switch 表达式和语句的完整性
. 模式变量的作用域
. 处理 null

[[java-18-feature-switch-description-switch-enhanced]]
===== 1、增强类型检查

[[java-18-feature-switch-description-switch-typing]]
====== 1a. 表达式类型

在 switch 中支持模式意味着我们可以放松当前对选择器表达式类型的限制。目前，普通的 switch 选择器表达式的类型必须是整数元类型 (char, byte, short, 或 int) 对应的包装类型  (Character, Byte, Short, 或 Integer)， String 或 enum 类型。扩展后，要求选择器表达式的类型为整型元类型或任何引用类型。

例如，在下面的 switch 语句中，选择器表达式 o 与 class 类型、enum 类型、record 类型和 array 类型匹配，包括(以及一个 null 和一个默认值):

[source,java]
----
record Point(int i, int j) {}
enum Color { RED, GREEN, BLUE; }

static void typeTester(Object o) {
    switch (o) {
        case null     -> System.out.println("null");
        case String s -> System.out.println("String");
        case Color c  -> System.out.println("Color with " + Color.values().length + " values");
        case Point p  -> System.out.println("Record class: " + p.toString());
        case int[] ia -> System.out.println("Array of ints of length" + ia.length);
        default       -> System.out.println("Something else");
    }
}
----

`switch` 块中的每个 case 语句必须与选择器表达式兼容。对于带有模式的 case 语句，我们称之为模式标签，我们使用了表达式与模式兼容的现有概念( https://docs.oracle.com/javase/specs/jls/se16/html/jls-14.html#jls-14.30.1[JLS §14.30.1])。

[[java-18-feature-switch-description-switch-Dominance]]
====== 1b. 模式标签的优势

选择器表达式可以匹配一个 switch 块中的多个 case 语句。考虑这个有问题的例子:

[source,java]
----
static void error(Object o) {
    switch(o) {
        case CharSequence cs ->
            System.out.println("A sequence of length " + cs.length());
        case String s ->    // Error - pattern is dominated by previous pattern
            System.out.println("A string: " + s);
        default -> {
            break;
        }
    }
}
----

第一个 case CharSequence cs 优于第二个 case String s，因为每个匹配 String s 的值也匹配 CharSequence cs，但反之不一样。这是因为第二个 String 的类型是第一个 CharSequence 的类型的子类。

形式为 case p 的模式语句，其中 p 是选择器表达式类型的 total  模式优于 case null。这是因为 total 模式匹配所有值，包括 `null`。

case p 的格式优于 case p && e，也就是说，模式是原始模式的一个被保护的版本。例如，case String s 优于 case String s && s.length() > 0，因为每个匹配 String s && s.length() > 0 的值也会匹配 String s。

[[java-18-feature-switch-description-switch-completeness]]
===== 2、switch 表达式和语句的完整性

switch 表达式要求选择器表达式的所有可能值都在 switch 块中处理。这将维护 switch 表达式的成功求值始终会产生一个值的属性。对于普通的 switch 表达式，这是通过 switch 块上一组相当简单的额外条件来实现的。对于 switch 表达式，我们定义了 switch 块的类型覆盖的概念。

[source,java]
----
static int coverage(Object o) {
    return switch (o) {         // Error - incomplete
        case String s  -> s.length();
        case Integer i -> i;
    };
}
----

这个 switch 块的类型覆盖是它的两个箭头规则覆盖的联合。换句话说，类型覆盖是 String 的所有子类型的集合和 Integer 的所有子类型的集合。但是，类型覆盖仍然不包括选择器表达式的类型，因此这个表达式也是不完整的，并会导致编译时错误。

default 的类型覆盖是所有类型，所以这个例子(终于!)是合法的:

[source,java]
----
static int coverage(Object o) {
    return switch (o) {
        case String s  -> s.length();
        case Integer i -> i;
        default -> 0;
    };
}
----

如果选择器表达式的类型是一个密封类( https://openjdk.java.net/jeps/409[JEP 409])，那么类型覆盖检查可以考虑密封类的 permit 子句，以确定 switch 块是否完整。考虑下面这个密封接口 S 的例子，它有三个允许的子类 A、B 和 C:

[source,java]
----
sealed interface S permits A, B, C {}
final class A implements S {}
final class B implements S {}
record C(int i) implements S {}  // Implicitly final

static int testSealedCoverage(S s) {
    return switch (s) {
        case A a -> 1;
        case B b -> 2;
        case C c -> 3;
    };
}
----

编译器可以确定 switch 块的类型覆盖是 A、B 和 C。因为选择器表达式的类型 S 是一个密封的接口，它允许的子类正是 A、B 和 C，所以这个 switch 块是完整的。因此，不需要 default 子句。

为了防止不兼容的单独编译，编译器会自动添加一个默认标签，其代码会抛出一个 `IncompatibleClassChangeError`。只有当密封的接口被更改并且 switch 代码没有被重新编译时，才会到达这个语句。实际上，编译器会为您强化代码。

switch 表达式的完整性的要求类似于选择器表达式是 enum 类的 switch 表达式的处理，如果 enum 类的每个常量都有子句，则不需要 default 子句。

让编译器验证 switch 表达式是否完整是非常有用的。我们将这种检查方法扩展到 switch 语句，而不是只对 switch 表达式进行检查。出于向后兼容性的原因，所有现有的 switch 语句都将不加修改地编译。但是，如果 switch 语句使用了本 JEP 中详细介绍的任何新特性，那么编译器将检查它是否完成。

更准确地说，对于使用模式或 `null` 标签的 switch 语句，或者选择器表达式不是传统类型 (char, byte, short, int, Character, Byte, Short, Integer, String, or an enum type) 的 switch 语句，要求完整性。

这意味着 switch 表达式和 switch 语句现在都可以获得更严格的类型检查的好处。例如:

[source,java]
----
sealed interface S permits A, B, C {}
final class A implements S {}
final class B implements S {}
record C(int i) implements S {}  // Implicitly final

static void switchStatementComplete(S s) {
    switch (s) {    // Error - incomplete; missing clause for permitted class B!
        case A a :
            System.out.println("A");
            break;
        case C c :
            System.out.println("B");
            break;
    };
}
----

要完成大多数 switch 语句，只需在 switch 语句体的末尾添加一个简单的 default 子句。这样可以更清晰、更容易地验证代码。例如，下面的 switch 语句是不完整的，是错误的:

[source,java]
----
Object o = ...
switch (o) {    // Error - incomplete!
    case String s:
        System.out.println(s);
        break;
    case Integer i:
        System.out.println("Integer");
        break;
}
----

改进为完整的:

[source,java]
----
Object o = ...
switch (o) {
    case String s:
        System.out.println(s);
        break;
    case Integer i:
        System.out.println("Integer");
        break;
    default:    // Now complete!
        break;
}
----

可能的情况是，Java 语言的未来编译器会对不完整的遗留 switch 语句发出警告。

[[java-18-feature-switch-description-switch-scope]]
===== 3、模式变量的作用域

模式变量( https://openjdk.java.net/jeps/394[JEP 394] )是模式声明的局部变量。模式变量声明的不同寻常之处在于它们的作用域是对流敏感的。回顾一下下面的例子，其中 String s 声明了模式变量 s:

[source,java]
----
static void test(Object o) {
    if ((o instanceof String s) && s.length() > 3) {
        System.out.println(s);
    } else {
        System.out.println("Not a string");
    }
}
----

s 的声明在 && 表达式的右边和 then 块的作用域中。但是，它不在 "else" 块的作用域中;为了将控制转移到 “else” 块，模式匹配必须失败，在这种情况下，模式变量将没有被初始化。

我们扩展了模式变量声明作用域这个对流敏感的概念，用两个新规则来包含 case 标签中出现的模式声明:

. 在 switch 的 case 语句中的模式变量的作用域包括出现在箭头右侧的表达式、block 或 throw 语句。
. 模式变量声明的作用域出现在 switch 标签语句组的 case 标签中，在这个 case 标签中没有后面的 switch 标签，它包括语句组的块语句。

下面的例子展示了第一条规则:

[source,java]
----
static void test(Object o) {
    switch (o) {
        case Character c -> {
            if (c.charValue() == 7) {
                System.out.println("Ding!");
            }
            System.out.println("Character");
        }
        case Integer i ->
            throw new IllegalStateException("Invalid Integer argument of value " + i.intValue());
        default -> {
            break;
        }
    }
}
----

变量 c 的作用域是第一个箭头右边的块。

变量 i 的作用域是第二个箭头右边的 throw 语句。

第二条规则更为复杂。让我们首先考虑一个例子，其中 switch 语句组只有一个 case 字句:

[source,java]
----
static void test(Object o) {
    switch (o) {
        case Character c:
            if (c.charValue() == 7) {
                System.out.print("Ding ");
            }
            if (c.charValue() == 9) {
                System.out.print("Tab ");
            }
            System.out.println("character");
        default:
            System.out.println();
    }
}
----

变量 c 的作用域包括语句组中的所有语句，即两个 if 语句和 println 语句。这个作用域不包括 default 组的语句。

必须排除通过声明模式变量的 case 标签出现编译时错误的可能性。看看这个错误的例子:

[source,java]
----
static void test(Object o) {
    switch (o) {
        case Character c:
            if (c.charValue() == 7) {
                System.out.print("Ding ");
            }
            if (c.charValue() == 9) {
                System.out.print("Tab ");
            }
            System.out.println("character");
        case Integer i:                 // Compile-time error
            System.out.println("An integer " + i);
        default:
            break;
    }
}
----

假设这种写法没有问题，并且选择器表达式 o 的值是一个字符，那么 switch 块在执行到 case Integer i:，其中变量 i 将不会被初始化。因此，允许执行以声明变量的 case 字句是一个编译时错误。

这就是为什么 case Character c: case Integer i: ...  是不允许的。类似的推理也适用于禁止 case 字句中的多个模式: case Character c, Integer i: ... 或 case Character c, Integer i -> ... 是不被允许的。如果允许这样的 case 字句，那么 c 和 i 都将在冒号或箭头之后的作用域内，但是 c 和 i 中只有一个会被初始化，这取决于 o 的值是字符还是整数。

另一方面，通过一个没有声明模式变量的子句是安全的，正如下面的例子所示:

[source,java]
----
void test(Object o) {
    switch (o) {
        case String s:
            System.out.println("A string");
        default:
            System.out.println("Done");
    }
}
----

[[java-18-feature-switch-description-switch-null]]
===== 4、处理 null

[[java-18-feature-switch-description-switch-null-matching]]
====== 4a 匹配 null

通常，如果选择器表达式的计算结果为 null, switch 会抛出 NullPointerException。这是很容易理解的行为，我们不建议为任何现有的 switch 代码更改它。

然而，考虑到模式匹配和空值有一个特殊的语义，在保持与现有 switch 语义兼容的同时，有机会使模式切换对 null 更加友好。

首先，我们为 case 引入了一个新的 null 标签，当选择器表达式的值为 null 时，它会明显匹配。

其次，我们观察到，如果选择器表达式的类型为 total 的模式出现了 case 标签，那么当选择器表达式的值为 null 时，该标签也将匹配。

NOTE:: 类型 U 的类型模式 p 对于类型 T 是 total，如果 T 是 U 的子类型。例如，类型模式对象 o 对于类型 String 是 total。

如果选择器表达式的值为 null，switch 会立即抛出 NullPointerException。相反，我们检查 case 标签来确定 switch 的行为:

* 如果选择器表达式的计算结果为 null，则表示匹配任何 null case 或 total 模式 case 。如果没有这样的标签与 switch 块相关联，那么 switch 抛出 NullPointerException，就像之前一样。
* 如果选择器表达式的计算结果为一个非空值，那么我们将一如既往地选择一个匹配的 case 标签。如果没有 case 标签匹配，则认为匹配所有匹配标签。

例如，给定下面的声明，求值 test(null) 将输出 null! 而不是抛出 NullPointerException:

[source,java]
----
static void test(Object o) {
    switch (o) {
        case null     -> System.out.println("null!");
        case String s -> System.out.println("String");
        default       -> System.out.println("Something else");
    }
}
----

这个关于 null 的新行为就好像编译器自动用一个 case null 来丰富 switch 块，它的 body 抛出 `NullPointerException`。换句话说，这段代码:

[source,java]
----
static void test(Object o) {
    switch (o) {
        case String s  -> System.out.println("String: " + s);
        case Integer i -> System.out.println("Integer");
        default  -> System.out.println("default");
    }
}
----

等价于

[source,java]
----
static void test(Object o) {
    switch (o) {
        case null      -> throw new NullPointerException();
        case String s  -> System.out.println("String: "+s);
        case Integer i -> System.out.println("Integer");
        default  -> System.out.println("default");
    }
}
----

在这两个例子中，求值 `test(null)` 将导致抛出 `NullPointerException`。

我们保留了现有 switch 结构的直觉，即执行对 null 的匹配是一件特殊的事情。模式 switch 的不同之处在于，你有一个机制可以直接在 switch 内部而不是外部处理这种情况。如果你选择在一个 switch 块中没有匹配 null 的 case 标签，那么 switch 一个 null 值将抛出 `NullPointerException`，就像之前一样。

[[java-18-feature-switch-description-switch-null-forms]]
====== 4b New label forms arising from null labels

JDK 16 中的 Switch 块支持两种风格:一种基于标记的语句组 (the : form) ，它可能出现 fall-through;另一种单一随后形式(the -> form)，它不可能出现 fall-through。在前一种风格中，多个标签通常写成 case l1: case l2:，而在后一种风格中，多个标签写成 case l1, l2:。

支持 null 标签意味着许多特殊情况可以用 : form 表示。例如:

[source,java]
----
Object o = ...
switch(o) {
    case null: case String s:
        System.out.println("String, including null");
        break;
    ...
}
----

我们期望 : 和 -> 都应该具有相同的表达性，如果前一种风格支持 情况A:情况B:，那么后一种风格应该支持 情况A, B ->。因此，前面的例子表明，我们应该支持 case null, String s -> 标签，如下所示:

[source,java]
----
Object o = ...
switch(o) {
    case null, String s -> System.out.println("String, including null");
    ...
}
----

当它是 null 引用或字符串时，o 的值匹配这个标签。在这两种情况下，变量 s 都用 o 的值初始化。

(反过来的形式，case String s, null 也应该被允许，并且行为相同。)

将 null case 与 default 标签结合使用也是有意义的(而且并不少见)，例如:

[source,java]
----
Object o = ...
switch(o) {
    ...
    case null: default:
        System.out.println("The rest (including null)");
}
----

同样，应该以 -> 形式支持这一点。为此，我们引入了一个新的 default case 标签:

[source,java]
----
Object o = ...
switch(o) {
    ...
    case null, default ->
        System.out.println("The rest (including null)");
}
----

o 的值匹配这个标签，如果它是 null 引用值，或者没有其他标签匹配。

[[java-18-feature-switch-guarded]]
==== 保护模式和括号模式

在成功的模式匹配之后，我们通常会进一步测试匹配的结果。这可能会导致繁琐的代码，例如:

[source,java]
----
static void test(Object o) {
    switch (o) {
        case String s:
            if (s.length() == 1) { ... }
            else { ... }
            break;
        ...
    }
}
----

所需要的测试— o 是长度为 1 的字符串—不幸地被分割为 case 标签和随后的 if 语句。如果 switch 模式支持 case 标签中的模式和布尔表达式的组合，我们可以提高可读性。

我们不是添加另一个特殊的 case 标签，而是通过添加保护模式(p && e)来增强模式语言。这允许重写上面的代码，以便所有的条件逻辑都被提升到 case 标签中:

[source,java]
----
static void test(Object o) {
    switch (o) {
        case String s && (s.length() == 1) -> ...
        case String s                      -> ...
        ...
    }
}
----

如果 o 是字符串且长度为 1，则第一个 case 匹配。如果 o 是一个其他长度的字符串，则第二种情况匹配。

有时我们需要将模式括起来以避免解析歧义。因此，我们扩展了模式语言以支持(p)编写的带括号的模式，其中 p 是一种模式。

更准确地说，我们改变了模式的语法。假设添加了 JEP 405 的记录模式和数组模式，模式语法将变为:

[source,java]
----
Pattern:
  PrimaryPattern
  GuardedPattern

GuardedPattern:
  PrimaryPattern && ConditionalAndExpression

PrimaryPattern:
  TypePattern
  RecordPattern
  ArrayPattern
----

一个被保护的模式是p && e的形式，其中p是一个模式，e是一个布尔表达式。在被保护的模式中，任何使用但没有在子表达式中声明的局部变量、形式参数或异常参数都必须是final或有效final。

一个被保护的模式p && e引入了模式p和表达式e引入的模式变量的并集。在p中任何模式变量声明的范围都包括表达式e。这允许像String s && (s.length() > 1)这样的模式，它匹配一个可以转换为String的值，这样该字符串的长度大于1。

一个值匹配一个被保护的模式p && e，首先，它匹配模式p，然后，表达式e的计算结果为true。如果值与p不匹配，则不会尝试对表达式e求值。

带括号的模式的形式是(p)，其中p是模式。圆括号中的模式(p)引入了由子模式p引入的模式变量。如果匹配模式p，值就匹配圆括号中的模式(p)。

例如，我们还将表达式的语法改为:

[source,java]
----
InstanceofExpression:
  RelationalExpression instanceof ReferenceType
  RelationalExpression instanceof PrimaryPattern
----

这个更改，以及保护模式语法规则中的非终结符ConditionalAndExpression，确保，例如，表达  e instanceof String s && s.length() > 1 继续明确解析表达式 (e instanceof String s) && (s.length() > 1)。如果 && 旨在保护模式的一部分,那么整个模式应该括号,例如,e instanceof (String s && s.length() > 1).

在语法规则中为保护模式使用非终结符ConditionalAndExpression还消除了另一个关于带有保护模式的case标签的潜在歧义。例如:

[source,java]
----
boolean b = true;
switch (o) {
    case String s && b -> s -> s;
}
----

如果一个被保护模式的保护表达式被允许为任意表达式，那么第一个出现的 -> 是 lambda 表达式的一部分还是 switch 规则的一部分(switch 规则的主体是 lambda 表达式)就会出现歧点。由于 lambda 表达式永远不可能是一个有效的布尔表达式，因此可以安全地限制保护表达式的语法。

[[java-18-feature-finalization]]
== 弃用 Finalization

finalization 它可以帮助我们主动释放系统底层资源，说实话，没用过，Java 是自动管理内存的，使用它反而会导致潜在的系统安全风险，没帮助不说反而是负担，所以计划移除了。

目前 finalization  已经标识为废弃状态了。但在未来版本暂时还不会删除。finalization 现在默认是开启的，但可以通过下面参数进行禁用：

[source,shell]
====
--finalization=disable
====

后续的版本会默认禁用，再逐步进行彻底删除，可以考虑使用其他的资源管理技术，如：try-with-resources（JDK 7+） 和 cleaners（JDK 9+）